diff --git a/pchip_code/np_msm_ingress_c.cpp b/pchip_code/np_msm_ingress_c.cpp
index b21a79d..faa3843 100644
--- a/pchip_code/np_msm_ingress_c.cpp
+++ b/pchip_code/np_msm_ingress_c.cpp
@@ -1113,6 +1113,7 @@ static void ones_checksum_frame(UINT8 * frame, UINT8 offset, UINT8 * buf, NPCHIP
 /*=========================================================================================*/
 /*=========================================================================================*/
 
+#include "common/stack_util.h"
 static UINT32 frame_count[2][EMU_MAX_CHAIN] = {};
 
 bool EM_NAME(ingress, 0) (bool refresh, UINT8 chain, UINT8 stream)
@@ -1213,7 +1214,9 @@ bool EM_NAME(ingress, 0) (bool refresh, UINT8 chain, UINT8 stream)
     if (ctrl.frame_length == 0) goto null_frame_0;
     UINT32 f_num;
     f_num = ++frame_count[0][chain];
-    pchip_logpf("\nEmulator 0:  chain %u ctxt=%u length=%u frame_num=%u (fr-num : %02x %02x %02x %02x)\n",
+    
+//    stackBackTrace();
+    pchip_logpf("\nEmulator 0:  chain %u ctxt=%u length=%u frame_num=%u (fr-num : %02x %02x %02x %02x)-Arun\n",
                 chain, ctrl.context.context, ctrl.frame_length, f_num, ((f_num >> 24) & 0xFF), ((f_num >> 16) & 0xFF), ((f_num >> 8) & 0xFF), (f_num & 0xFF));
     packet_len_0 = ctrl.frame_length;
 
diff --git a/pchip_code/vfp_egress_c.cpp b/pchip_code/vfp_egress_c.cpp
index 21bc0a8..62b4d43 100755
--- a/pchip_code/vfp_egress_c.cpp
+++ b/pchip_code/vfp_egress_c.cpp
@@ -3525,6 +3525,7 @@ vfp_egr_msm_raw_handler(tVfpPacketDesc *pDesc, SW_FABRIC_HEADER *sw_fab_hdr)
     else 
     {
         if (msm_sw_fab_hdr.parm.raw.main.to_msm.reason.msm_reason == TO_MSM_REASON_ESP) { /*LOG(); TODO*/ goto process_esp_to_ipsmg; }
+//        if (msm_sw_fab_hdr.parm.raw.main.to_msm.reason.msm_reason == TO_MSM_REASON_LI) { LOG(); goto process_li; }
         if (msm_sw_fab_hdr.parm.raw.main.to_msm.reason.msm_reason >= TO_MSM_REASON_TCP) { LOG(); goto process_to_mscp; }
 
 //        if (msm_sw_fab_hdr.parm.raw.main.to_msm.reason.msm_reason == TO_MSM_REASON_IKE) { LOG(); goto process_to_mscp; } // Covered by previous statement
@@ -3535,6 +3536,7 @@ vfp_egr_msm_raw_handler(tVfpPacketDesc *pDesc, SW_FABRIC_HEADER *sw_fab_hdr)
         if (msm_sw_fab_hdr.parm.raw.main.to_msm.from_cpm != 0) { /*LOG_MSM_FWD();*/ goto process_to_mscp; }
     }
 
+
     if (likely(msm_sw_fab_hdr.parm.raw.main.to_msm.from_iom != 0))
     {
         //LOG_MSM_FWD();
diff --git a/pchip_code/vfp_ingress_c.cpp b/pchip_code/vfp_ingress_c.cpp
index 92258ee..5f9a463 100755
--- a/pchip_code/vfp_ingress_c.cpp
+++ b/pchip_code/vfp_ingress_c.cpp
@@ -418,6 +418,10 @@ typedef struct t_ing_zeroed {
     BOOLEAN             source_is_spoke;                    //  + 1 = 23
     BOOLEAN             drop_frame_if_route_da_mcast;       //  + 1 = 24
     LOCAL_SUB_APP_INDEX subscriber_app_index;               // KWH TODO - temp, move out!
+    struct
+    {
+        F_UINT(1,                    msm_sdf_li);
+    };
 } t_ing_zeroed;
 
 #ifdef GCC_ABI_64
@@ -7132,6 +7136,7 @@ routing_dest_lookup:
             ing.discard_stat_num = INGRESS_STAT_MSM_DPI_OR_LCP_NULL_FRAME;    
             goto dont_forward_just_copy;
         }
+//        goto dont_forward_just_copy_msm;
     }
     
     if (unlikely(!vfp_ing_routing_dest_lookup(pDesc, worker_info,  VFP_FWD_PATH_IP_ROUTING, port_record, routing_dest_index, &ing, &hash_res, &new_nhlfe_inner, &dest_vrf_id, &if_dest_info,
@@ -7245,6 +7250,13 @@ handle_dest_and_q_ucast:
 
     PCHIP_ASSERT(!ing.discard_stat_num); // I don't think there is any case for this
     
+    //pchip_logpf("ing.fwd_path: %d is LI: %d, msm.msm_stats: %d\n", ing.fwd_path, ing.msm_sdf_li, msm.msm_stats);
+#if 1
+    if (msm.msm_stats) {
+        goto dont_forward_just_copy_msm;
+    }
+#endif
+
     return vfp_ing_build_qhdr_and_output(pDesc, worker_info, sw_hdr, dest_queue, queue_stat_addr,
                                          (ing_qos.drop_pref == DROP_PREF_HIGH_PRIORITY),
                                          output_frame_offset, extra_header_size, payload_length, 0 /*mgid*/, &msm);
@@ -7474,6 +7486,31 @@ msm_dpi_join:
 
     if (likely(sw_hdr.parm.raw.main.to_msm.reason.msm_reason != TO_MSM_REASON_LI)) { LOG_MSM(); goto msm_non_li; }
 
+    pchip_logpf("LI Peer %d Context %d ICE %d\n", sw_hdr.parm.raw.main.to_msm.li.peer_id, sw_hdr.parm.raw.main.to_msm.li.context_id, sw_hdr.parm.raw.main.to_msm.li.ice_type);
+//    read_INGRESS_MSM_LI_NEXTHOP_TABLE(chain, &msm_session_nexthop, sw_hdr.parm.raw.main.to_msm.li.peer_id);
+//    read_INGRESS_MSM_LI_CONTEXT_TABLE(chain, &msm_li_context_info, sw_hdr.parm.raw.main.to_msm.li.context_id);
+
+    msm.msm_encap_protocol = IP_PROTOCOL_UDP;
+    msm_header_size = UDP_HEADER__BYTES + ULIC_HEADER__BYTES;
+    msm.msm_frame_length += msm_header_size;
+    msm_tunnel_id.composite.session.direction = sw_hdr.parm.raw.main.to_msm.direction; 
+
+    msm_sa_index.is_peer = 1;
+    msm_sa_index.peer_id = sw_hdr.parm.raw.main.to_msm.li.peer_id;
+
+    ing.ip_ptr = frame_start + msm.msm_overhead_length;
+
+    dont_care(msm_qci_policy_id);
+    dont_care(msm_default_qci);
+    dont_care(msm_tos);
+    dont_care(msm_sdf_rec);
+    dont_care(msm_bearer_rec);
+    dont_care(msm_int_info);
+    dont_care(msm_sdf_nh_index);
+//    dont_care(msm_sdf_ignore_redir_drop);
+    msm_bearer_rec.nh_info.encap = MSM_ENCAP_ULIC;
+    goto msm_li_encap;
+
 msm_non_li:          
     
     UINT8 tunnel_bytes[MSM_TUNNEL_ID__BYTES];
@@ -7518,10 +7555,11 @@ msm_non_li:
                 msm_int_info.sdf_id, msm_tos);
 
 //done_ul_bearer_rat: // add this one when ecmp support is added
-    UINT32 len = 0;
+    UINT32 len;
     UINT8 arr[MAX_HASH_KEY_BYTES];
 
     PCHIP_ZERO(msm_sdf_lookup_key);
+    len = 0;
     
     msm_sdf_lookup_key.key.session_id.chunk = msm_tunnel_id.composite.session.chunk;
     msm_sdf_lookup_key.key.session_id.session = msm_tunnel_id.composite.session.session;
@@ -7593,6 +7631,7 @@ got_sdf:
     msm_sdf_rec_cp = *msm_sdf_rec;
     msm_bearer_rec_id = msm_sdf_rec->id;
     msm_bearer_rec_id.dir = msm_tunnel_id.composite.session.direction;
+    ing.msm_sdf_li = msm_sdf_rec->sdf_li;
 
     pchip_logpf("Bearer idx%d\n", MSM_BEARER_ENCAP_ID_MAP(msm_bearer_rec_id));
     
@@ -7836,6 +7875,8 @@ got_sdf:
     msm.msm_frame_length = msm_header_size + msm.msm_frame_length;
     msm_sa_index.intf_id = msm_session_nexthop_cp.intf_id;
 
+msm_li_encap:
+
     PCHIP_ZERO(msm_encap);
     PCHIP_ZERO(msm_ip_l4_rewrite_size);
     source_vrf_id = msm_session_nexthop_cp.nh.vrf_id;
@@ -8495,7 +8536,7 @@ msm_encap_ulic_done:
         msm.spi_or_teid = msm_bearer_rec.tunnel_id & 0xfffff;
 //        hash_res = vfp_ing_hash_bits((UINT8 *) &ipv4_hdr.addresses, IP_ADDRESS__BITS * 2);
         hash_res = vfp_ing_hash64(msm_tunnel_id.id, hash_res);
-        pchip_logpf("MSCP Hash 0x%06x\n", hash_res);
+        pchip_logpf("MSCP Hash GTP 0x%06x\n", hash_res);
         if (likely(ing.ip_ptr != NOT_AN_IP_FRAME))
         {
             output_frame_offset = ing.ip_ptr - frame_start;
@@ -8686,7 +8727,7 @@ mscp_route_packet:
 //        pchip_logpf("IPv4 DA %d.%d.%d.%d TOS 0x%02x OutTE-ID 0x%08x\n", PRINT_IPV4(psi.ip_routing.ipv4_da_for_routing_lookup), ipv4_hdr.TOS, msm_tunnel_id.id); 
         hash_res = vfp_ing_hash_bits((UINT8 *) &ipv4_hdr.addresses, IP_ADDRESS__BITS * 2);
         hash_res = vfp_ing_hash64(msm_tunnel_id.id, hash_res);
-        pchip_logpf("MSCP Hash 0x%06x\n", hash_res);
+        pchip_logpf("MSCP Hash v4 0x%06x\n", hash_res);
         incoming_ttl = ipv4_hdr.ttl;
 #if 0
         // TODO - Discard TTL <= 1
@@ -8727,7 +8768,7 @@ mscp_route_packet:
         ing.is_ipv6 = 1;
         msm.non_svc_bits1.route_lookup_only = 1;
         // TODO - Discard TTL <= 1
-        pchip_logpf("MSCP Hash 0x%06x\n", hash_res);
+        pchip_logpf("MSCP Hash v6 0x%06x\n", hash_res);
         goto multicast_and_routing_common_v6;
     }
     }
@@ -8810,9 +8851,11 @@ dont_forward_just_copy_msm:
     {
     FIXED_QUEUE_VOQ_INFO *mscp_queue_voq_info = NULL;
     SW_FABRIC_HEADER  *msm_fab_hdr = NULL;
+    bool li_pkt = 0;
 //    T_Q2_VFP_HEADER *q2_hdr;
     LOG();
 
+
     if ((ing.fwd_path == VFP_FWD_PATH_MSM) && (msm.msm_ctxts.type != MSM_CTXT_GTP_LPBK))
     {
         if (ing.discard_stat_num != INGRESS_STAT_NP_DROP_NO_COUNTS)
@@ -8852,6 +8895,98 @@ dont_forward_just_copy_msm:
         msm_fab_hdr->parm.raw.main.to_msm.performed_dpi = msm.msm_ctxts.performed_dpi;
         msm_fab_hdr->parm.raw.main.to_msm.flow_identified = msm.msm_dpi.flow_identified;
     }
+    else
+    {
+        if (msm.msm_stats == 0) {
+            goto msm_not_li;
+        }
+        MSM_LI_INFO msm_li_info;
+
+        if (!msm.msm_stat_ids) {
+            pchip_logpf("msm.msm_stat_ids null\n");
+            goto msm_not_li;
+        }
+        msm_li_info = msm.msm_stat_ids->li_info;
+        pchip_logpf("Vfp LI?? %d context %d ice %d, ing.msm_sdf_li: %d\n", msm_li_info.peer_id, msm_li_info.context_id, msm_li_info.ice_type, ing.msm_sdf_li);
+        if (ing.discard_stat_num != INGRESS_STAT_NP_DROP_NO_COUNTS)
+        {
+            if (ing.discard_stat_num != 0) {
+                pchip_logpf("ing.discard_stat_num is non-zero - z: %d\n", ing.discard_stat_num);
+                return vfp_ing_discard(pDesc, ing.discard_stat_num, port_record);
+            }
+        }
+
+        mscp_queue_voq_info = &INGRESS_MSM_MSCP_QUEUE_VOQ_TABLE_CTABLE[0];
+        msm_fab_hdr = (SW_FABRIC_HEADER *)frame_start;
+        rte_memset((UINT8 *)msm_fab_hdr, 0, sizeof(SW_FABRIC_HEADER));
+        msm_fab_hdr->parm.raw.main.to_msm.sdf_id = msm_int_info.sdf_id;
+
+        if (ing.discard_stat_num != 0) {
+            pchip_logpf("ing.discard_stat_num is non-zero: %d\n", ing.discard_stat_num);
+            goto msm_not_li;
+        }
+
+        if (msm_li_info.peer_id == 0) goto chk_sdf_li;
+        if (msm_li_info.context_id == 0) goto chk_sdf_li;
+        goto li_to_mscp;
+
+chk_sdf_li:
+        if (ing.msm_sdf_li == 0) {
+            pchip_logpf("msm_sdf_li is zero.. Skip Li...\n");
+            goto msm_not_li;
+        }
+
+li_to_mscp:
+//        LOG_MSM();
+
+#if 0
+//        read_INGRESS_MSM_LI_QUEUE_VOQ_TABLE(chain, &filter_queue_voq_info, msm_do_li_on_mscp);
+        MSM_TUNNEL_ID msm_tunnel_id;                                                      
+        PCHIP_ZERO(msm_tunnel_id);                                                        
+        msm_tunnel_id.composite.session.session = ing.session;                            
+        msm_tunnel_id.composite.session.chunk = ing.chunk_id;                             
+        UINT8 tunnel_bytes[MSM_TUNNEL_ID__BYTES];                                         
+        convert_from_MSM_TUNNEL_ID(&msm_tunnel_id, tunnel_bytes, MSM_TUNNEL_ID_composite);
+        convert_to_MSM_TUNNEL_ID(&msm_tunnel_id, tunnel_bytes, MSM_TUNNEL_ID_id);         
+
+        filter_log_hdr.sw_hdr.parm.raw.main.to_msm.tunnel_id = msm_tunnel_id.id;
+        filter_log_hdr.sw_hdr.parm.raw.main.to_msm.reason.msm_reason = TO_MSM_REASON_LI;
+        filter_log_hdr.sw_hdr.parm.raw.main.to_msm.li = msm_li_info;
+        filter_log_hdr.sw_hdr.parm.raw.main.to_msm.direction = ing.msm_dir;
+#endif
+
+#if 0
+            MSM_TUNNEL_ID msm_tunnel_id;
+            PCHIP_ZERO(msm_tunnel_id);
+            //msm_tunnel_id.composite.session = msm.msm_ctxts.redirect.session;
+            msm_tunnel_id.composite.session = msm_sdf_lookup_key.key.session_id.session;
+#endif
+            UINT8 tunnel_bytes[MSM_TUNNEL_ID__BYTES];
+            convert_from_MSM_TUNNEL_ID(&msm_tunnel_id, tunnel_bytes, MSM_TUNNEL_ID_composite);
+            convert_to_MSM_TUNNEL_ID(&msm_tunnel_id, tunnel_bytes, MSM_TUNNEL_ID_id);
+            msm_fab_hdr->parm.raw.main.to_msm.tunnel_id = msm_tunnel_id.id;
+
+        msm_fab_hdr->parm.raw.main.to_msm.reason.msm_reason = TO_MSM_REASON_LI;
+        msm_fab_hdr->parm.raw.main.to_msm.li = msm_li_info;
+        msm_fab_hdr->parm.raw.main.to_msm.direction = msm.msm_dir;
+        pchip_logpf("Vfp MSM LI peer %d context %d ice %d, Li-Reason: %d, tunnel_id: %d\n", msm_li_info.peer_id, msm_li_info.context_id, msm_li_info.ice_type, TO_MSM_REASON_LI, msm_tunnel_id.id);
+
+        pDesc->data_offset += sizeof(*msm_fab_hdr);
+        pDesc->data_length -= sizeof(SW_FABRIC_HEADER);
+        li_pkt = 1;
+        pchip_logpf("AGAIN FrameLength %d TunnelId 0x%08x (%d:%d:%d) dir %d bearer 0x%01x SDF Instance %d, TOS %02x\n", 
+                msm.msm_frame_length, 
+                msm_fab_hdr->parm.raw.main.to_msm.tunnel_id,
+                msm_tunnel_id.composite.session.chunk,
+                msm_tunnel_id.composite.session.session,
+                msm_tunnel_id.composite.session.indirect,
+                msm_tunnel_id.composite.session.direction,
+                msm_tunnel_id.composite.bearer,
+                msm_int_info.sdf_id, msm_tos);
+
+    }
+
+msm_not_li:
 
     msm_fab_hdr->common.qos.in_profile = IN_PROFILE_GREEN;
     msm_fab_hdr->common.qos.fc = 0x7;
@@ -8886,6 +9021,10 @@ dont_forward_just_copy_msm:
     pDesc->u.to_worker.handler = VFP_WORKER_HANDLER_EGRESS;
     pDesc->u.to_worker.context = 0;
 
+    if (li_pkt) {
+//        pDesc->u.to_worker.handler = VFP_WORKER_HANDLER_INGRESS;
+    }
+
 
     pchip_logpf("Redirect/ LI  data_length  %u data_offset %u\n", pDesc->data_length, pDesc->data_offset);
     return TRUE;
