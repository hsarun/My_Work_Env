diff --git a/pchip_code/vfp_ingress_c.cpp b/pchip_code/vfp_ingress_c.cpp
index 81758ea..e4fa134 100755
--- a/pchip_code/vfp_ingress_c.cpp
+++ b/pchip_code/vfp_ingress_c.cpp
@@ -420,6 +420,10 @@ typedef struct t_ing_zeroed {
     BOOLEAN             source_is_spoke;                    //  + 1 = 23
     BOOLEAN             drop_frame_if_route_da_mcast;       //  + 1 = 24
     LOCAL_SUB_APP_INDEX subscriber_app_index;               // KWH TODO - temp, move out!
+    struct
+    {
+        F_UINT(1,                    msm_sdf_li);
+    };
 } t_ing_zeroed;
 
 #ifdef GCC_ABI_64
@@ -1824,6 +1828,157 @@ vfp_ing_lcp_reason(TO_LCP_ICMP_CODE icmp_code)
 }
 
 static void
+vfp_ing_dup_to_msm (tVfpPacketDesc *pDesc,
+                    const VFP_INGRESS_PORT_RECORD *port_record,
+                    NPCHIP_FRAME_LEN extra_header_size,
+                    NPCHIP_FRAME_LEN payload_length, UINT32 output_frame_offset,
+                    UINT8 reason_code,
+                    t_vfp_msm_reason *msm,
+                    MSM_LI_INFO *msm_li_info,
+                    MSM_INT_INFO *msm_int_info,
+                    MSM_TUNNEL_ID *msm_tunnel_id)
+{
+
+#ifdef VFP_FP
+    tPktBuf *msm_pbuf = vfp_pchip_pbuf_alloc();
+    if (!msm_pbuf)
+        return;
+    UINT8 *real_msm_hdr = PBUF_DPTR8(msm_pbuf);
+#else
+    UINT8 real_msm_hdr [sizeof(SW_FABRIC_HEADER) + sizeof(T_Q2_VFP_HEADER)]; // KWH TODO - could build on pbuf, but for now build separately in case we need to dup?
+#endif
+    const FIXED_QUEUE_VOQ_INFO *msm_queue_voq_info;
+    SW_FABRIC_HEADER *msm_sw_hdr = (SW_FABRIC_HEADER *) &real_msm_hdr[sizeof(T_Q2_VFP_HEADER)];
+    T_Q2_VFP_HEADER *msm_q2_hdr = (T_Q2_VFP_HEADER *) &real_msm_hdr[0];
+
+    UINT8 tunnel_bytes[MSM_TUNNEL_ID__BYTES];
+
+    PCHIP_MEMZERO(real_msm_hdr, sizeof(SW_FABRIC_HEADER) + sizeof(T_Q2_VFP_HEADER));
+
+    pchip_logpf("Frame to MSM (%u)\n", reason_code);
+    convert_from_MSM_TUNNEL_ID(msm_tunnel_id, tunnel_bytes, MSM_TUNNEL_ID_composite);
+    convert_to_MSM_TUNNEL_ID(msm_tunnel_id, tunnel_bytes, MSM_TUNNEL_ID_id);
+    msm_sw_hdr->parm.raw.main.to_msm.tunnel_id = msm_tunnel_id->id;
+
+    msm_sw_hdr->parm.raw.main.to_msm.reason.msm_reason = reason_code;
+    msm_sw_hdr->parm.raw.main.to_msm.li = *msm_li_info;
+    msm_sw_hdr->parm.raw.main.to_msm.direction = msm->msm_dir;
+
+    msm_sw_hdr->common.qos.in_profile = IN_PROFILE_GREEN;
+    msm_sw_hdr->common.qos.fc = 0x7;
+    msm_sw_hdr->common.type = SW_FRAME_TYPE_RAW;
+    msm_sw_hdr->parm.raw.complex_port.port = port_record->my_port;
+
+    msm_sw_hdr->parm.raw.main.is_to_msm = 1;
+    msm_sw_hdr->parm.raw.main.to_msm.reason.mda_offset = 1;
+    msm_sw_hdr->parm.raw.main.to_msm.sdf_id = msm_int_info->sdf_id;
+    msm_sw_hdr->parm.raw.complex_port.complex = port_record->my_complex;
+
+    msm_queue_voq_info = &INGRESS_MSM_MSCP_QUEUE_VOQ_TABLE_CTABLE[0];
+    msm_q2_hdr->queue_index = msm_queue_voq_info->queue_num;
+
+    msm_q2_hdr->stat_index1 = msm_q2_hdr->queue_index << 1;
+    if (!msm_q2_hdr->queue_index) return;
+    msm_q2_hdr->start_offset = msm_q2_hdr->output_length - pDesc->data_length;
+
+    msm_q2_hdr->voq_index = msm_queue_voq_info->voq_num;
+
+    msm_q2_hdr->output_context = msm_queue_voq_info->output_context;
+    msm_q2_hdr->output_length = sizeof(SW_FABRIC_HEADER) + extra_header_size + payload_length;
+
+    pchip_logpf("Vfp MSM LI peer %d context %d ice %d, Li-Reason: %d, tunnel_id: 0x%x\n", msm_li_info->peer_id, msm_li_info->context_id, msm_li_info->ice_type, TO_MSM_REASON_LI, msm_tunnel_id->id);
+    pchip_logpf("FrameLength %d TunnelId 0x%08x (%d:%d:%d) dir %d bearer 0x%01x SDF Instance %d\n",
+                msm->msm_frame_length,
+                msm_sw_hdr->parm.raw.main.to_msm.tunnel_id,
+                msm_tunnel_id->composite.session.chunk,
+                msm_tunnel_id->composite.session.session,
+                msm_tunnel_id->composite.session.indirect,
+                msm_tunnel_id->composite.session.direction,
+                msm_tunnel_id->composite.bearer,
+                msm_int_info->sdf_id);
+
+#ifndef VFP_FP
+    COMBINED_FC_CTRL p1_fc_ctrl;
+    PCHIP_ZERO(p1_fc_ctrl);
+
+    p1_fc_ctrl.ctrl.frame_length = pDesc->data_length;
+    p1_fc_ctrl.ctrl.context.context = 0/*context*/;
+    p1_fc_ctrl.ctrl_out.end_byte_offset_plus_one_in_input_buffer = msm_q2_hdr->output_length + sizeof(T_Q2_VFP_HEADER);
+    p1_fc_ctrl.ctrl_out.header_length = sizeof(SW_FABRIC_HEADER) + sizeof(T_Q2_VFP_HEADER);
+    p1_fc_ctrl.ctrl_out.keep_frame = 1;
+
+    p1_fc_ctrl.ctrl_out.start_byte_offset_in_input_buffer = output_frame_offset;
+    pchip_logpf("msm output_frame frame start offset is %u, header_length is %u, start byte in input buffer is %u, end byte plus one is %u\n",
+                output_frame_offset, p1_fc_ctrl.ctrl_out.header_length, p1_fc_ctrl.ctrl_out.start_byte_offset_in_input_buffer, p1_fc_ctrl.ctrl_out.end_byte_offset_plus_one_in_input_buffer);
+    npchip_output_frame(&p1_fc_ctrl.ctrl, &p1_fc_ctrl.ctrl_out, (UINT8 *) msm_q2_hdr);
+#else
+    rte_memcpy(&real_msm_hdr[sizeof(SW_FABRIC_HEADER) + sizeof(T_Q2_VFP_HEADER)], VFP_PACKET_DESC_GET_DPTR(pDesc) + output_frame_offset, msm_q2_hdr->output_length - sizeof(SW_FABRIC_HEADER));
+
+    msm_pbuf->DataOff += sizeof(T_Q2_VFP_HEADER);
+    msm_pbuf->DataLen = msm_q2_hdr->output_length;
+    PCHIP_ASSERT((msm_pbuf->DataOff + msm_pbuf->DataLen) <= msm_pbuf->BufSize);
+    pchip_logpf("msm output_frame frame start offset is %u, header_length is %u\n",
+            msm_pbuf->DataOff, msm_pbuf->DataLen);
+
+    VFP_PACKET_DESC_CHAIN(pDesc, msm_pbuf);
+#endif
+}
+
+static inline void __attribute__((always_inline))
+vfp_ing_dup_to_msm_li(tVfpPacketDesc *pDesc,
+                      const VFP_INGRESS_PORT_RECORD *port_record, 
+                      NPCHIP_FRAME_LEN extra_header_size,
+                      NPCHIP_FRAME_LEN payload_length, UINT32 output_frame_offset,
+                      t_vfp_msm_reason *msm,
+                      MSM_INT_INFO *msm_int_info,
+                      MSM_TUNNEL_ID *msm_tunnel_id,
+                      t_ing_zeroed *ing)
+{
+    MSM_LI_INFO msm_li_info;
+
+    if (msm->msm_stats == 0) {
+        goto msm_not_li;
+    }
+
+    if (!(msm->msm_stat_ids)) {
+        pchip_logpf("msm.msm_stat_ids null\n");
+        goto msm_not_li;
+    }
+
+    if (ing->discard_stat_num != INGRESS_STAT_NP_DROP_NO_COUNTS)
+    {
+        if (ing->discard_stat_num != 0) {
+            pchip_logpf("ing->discard_stat_num is non-zero - z: %d\n", ing->discard_stat_num);
+            //vfp_ing_discard(pDesc, ing->discard_stat_num, port_record);
+            return;
+        }
+    }
+
+    if (!(msm->msm_stat_ids->do_li_on_mscp)) {
+        return;
+    }
+
+    msm_li_info = msm->msm_stat_ids->li_info;
+    if (msm_li_info.peer_id == 0) goto chk_sdf_li;
+    if (msm_li_info.context_id == 0) goto chk_sdf_li;
+    goto li_to_mscp;
+
+chk_sdf_li:
+    if (ing->msm_sdf_li == 0) {
+        pchip_logpf("msm_sdf_li is zero.. Skip Li...\n");
+        goto msm_not_li;
+    }
+
+li_to_mscp:
+    //        LOG_MSM();
+
+    vfp_ing_dup_to_msm(pDesc, port_record, extra_header_size, payload_length, output_frame_offset, TO_MSM_REASON_LI, msm, &msm_li_info, msm_int_info, msm_tunnel_id);
+
+msm_not_li:
+    return;
+}
+
+static void
 vfp_ing_dup_to_lcp_icmp(tVfpPacketDesc *pDesc,
                             TO_LCP_ICMP_CODE icmp_code, const VFP_INGRESS_PORT_RECORD *port_record, 
                             IOM_VRF_ID vrf_id, IOM_IP_INTERFACE_INDEX src_if,
@@ -7462,6 +7617,11 @@ handle_dest_and_q_ucast:
 
     PCHIP_ASSERT(!ing.discard_stat_num); // I don't think there is any case for this
     
+    if (msm.msm_stats) {
+
+        vfp_ing_dup_to_msm_li(pDesc, port_record, extra_header_size, payload_length, output_frame_offset, &msm, &msm_int_info, &msm_tunnel_id, &ing);
+    }
+
     return vfp_ing_build_qhdr_and_output(pDesc, worker_info, sw_hdr, dest_queue, queue_stat_addr,
                                          (ing_qos.drop_pref == DROP_PREF_HIGH_PRIORITY),
                                          output_frame_offset, extra_header_size, payload_length, 0 /*mgid*/, &msm);
@@ -7691,6 +7851,32 @@ msm_dpi_join:
 
     if (likely(sw_hdr.parm.raw.main.to_msm.reason.msm_reason != TO_MSM_REASON_LI)) { LOG_MSM(); goto msm_non_li; }
 
+#if 1
+    pchip_logpf("LI Peer %d Context %d ICE %d\n", sw_hdr.parm.raw.main.to_msm.li.peer_id, sw_hdr.parm.raw.main.to_msm.li.context_id, sw_hdr.parm.raw.main.to_msm.li.ice_type);
+
+    msm.msm_encap_protocol = IP_PROTOCOL_UDP;
+    msm_header_size = UDP_HEADER__BYTES + ULIC_HEADER__BYTES;
+    msm.msm_frame_length += msm_header_size;
+    msm_tunnel_id.composite.session.direction = sw_hdr.parm.raw.main.to_msm.direction;
+
+    msm_sa_index.is_peer = 1;
+    msm_sa_index.peer_id = sw_hdr.parm.raw.main.to_msm.li.peer_id;
+
+    ing.ip_ptr = frame_start + msm.msm_overhead_length;
+
+    dont_care(msm_qci_policy_id);
+    dont_care(msm_default_qci);
+    dont_care(msm_tos);
+    dont_care(msm_sdf_rec);
+    dont_care(msm_bearer_rec);
+    dont_care(msm_int_info);
+    dont_care(msm_sdf_nh_index);
+//    dont_care(msm_sdf_ignore_redir_drop);
+    msm_bearer_rec.nh_info.encap = MSM_ENCAP_ULIC;
+    goto msm_li_encap;
+#endif
+
+
 msm_non_li:          
     
     UINT8 tunnel_bytes[MSM_TUNNEL_ID__BYTES];
@@ -7735,10 +7921,11 @@ msm_non_li:
                 msm_int_info.sdf_id, msm_tos);
 
 //done_ul_bearer_rat: // add this one when ecmp support is added
-    UINT32 len = 0;
+    UINT32 len;
     UINT8 arr[MAX_HASH_KEY_BYTES];
 
     PCHIP_ZERO(msm_sdf_lookup_key);
+    len = 0;
     
     msm_sdf_lookup_key.key.session_id.chunk = msm_tunnel_id.composite.session.chunk;
     msm_sdf_lookup_key.key.session_id.session = msm_tunnel_id.composite.session.session;
@@ -7810,6 +7997,7 @@ got_sdf:
     msm_sdf_rec_cp = *msm_sdf_rec;
     msm_bearer_rec_id = msm_sdf_rec->id;
     msm_bearer_rec_id.dir = msm_tunnel_id.composite.session.direction;
+    ing.msm_sdf_li = msm_sdf_rec->sdf_li;
 
     pchip_logpf("Bearer idx%d\n", MSM_BEARER_ENCAP_ID_MAP(msm_bearer_rec_id));
     
@@ -8054,6 +8242,9 @@ got_sdf:
     }
     msm.msm_frame_length = msm_header_size + msm.msm_frame_length;
     msm_sa_index.intf_id = msm_session_nexthop_cp.intf_id;
+    goto msm_li_encap;
+
+msm_li_encap:
 
     PCHIP_ZERO(msm_encap);
     PCHIP_ZERO(msm_ip_l4_rewrite_size);
@@ -9063,6 +9254,73 @@ dont_forward_just_copy_msm:
         msm_fab_hdr->parm.raw.main.to_msm.performed_dpi = msm.msm_ctxts.performed_dpi;
         msm_fab_hdr->parm.raw.main.to_msm.flow_identified = msm.msm_dpi.flow_identified;
     }
+#if 0
+// Have moved Code to vfp_ing_dup_to_msm_li()
+    else
+    {
+        if (msm.msm_stats == 0) {
+            goto msm_not_li;
+        }
+        MSM_LI_INFO msm_li_info;
+
+        if (!msm.msm_stat_ids) {
+            pchip_logpf("msm.msm_stat_ids null\n");
+            goto msm_not_li;
+        }
+        msm_li_info = msm.msm_stat_ids->li_info;
+        if (ing.discard_stat_num != INGRESS_STAT_NP_DROP_NO_COUNTS)
+        {
+            if (ing.discard_stat_num != 0) {
+                pchip_logpf("ing.discard_stat_num is non-zero - z: %d\n", ing.discard_stat_num);
+                return vfp_ing_discard(pDesc, ing.discard_stat_num, port_record);
+            }
+        }
+
+        mscp_queue_voq_info = &INGRESS_MSM_MSCP_QUEUE_VOQ_TABLE_CTABLE[0];
+        msm_fab_hdr = (SW_FABRIC_HEADER *)frame_start;
+        rte_memset((UINT8 *)msm_fab_hdr, 0, sizeof(SW_FABRIC_HEADER));
+        msm_fab_hdr->parm.raw.main.to_msm.sdf_id = msm_int_info.sdf_id;
+
+        if (msm_li_info.peer_id == 0) goto chk_sdf_li;
+        if (msm_li_info.context_id == 0) goto chk_sdf_li;
+        goto li_to_mscp;
+
+chk_sdf_li:
+        if (ing.msm_sdf_li == 0) {
+            pchip_logpf("msm_sdf_li is zero.. Skip Li...\n");
+            goto msm_not_li;
+        }
+
+li_to_mscp:
+//        LOG_MSM();
+
+        UINT8 tunnel_bytes[MSM_TUNNEL_ID__BYTES];
+        convert_from_MSM_TUNNEL_ID(&msm_tunnel_id, tunnel_bytes, MSM_TUNNEL_ID_composite);
+        convert_to_MSM_TUNNEL_ID(&msm_tunnel_id, tunnel_bytes, MSM_TUNNEL_ID_id);
+        msm_fab_hdr->parm.raw.main.to_msm.tunnel_id = msm_tunnel_id.id;
+
+        msm_fab_hdr->parm.raw.main.to_msm.reason.msm_reason = TO_MSM_REASON_LI;
+        msm_fab_hdr->parm.raw.main.to_msm.li = msm_li_info;
+        msm_fab_hdr->parm.raw.main.to_msm.direction = msm.msm_dir;
+        pchip_logpf("Vfp MSM LI peer %d context %d ice %d, Li-Reason: %d, tunnel_id: %d\n", msm_li_info.peer_id, msm_li_info.context_id, msm_li_info.ice_type, TO_MSM_REASON_LI, msm_tunnel_id.id);
+
+        pDesc->data_offset += sizeof(*msm_fab_hdr);
+        pDesc->data_length -= sizeof(SW_FABRIC_HEADER);
+        pchip_logpf("AGAIN FrameLength %d TunnelId 0x%08x (%d:%d:%d) dir %d bearer 0x%01x SDF Instance %d, TOS %02x\n",
+                msm.msm_frame_length,
+                msm_fab_hdr->parm.raw.main.to_msm.tunnel_id,
+                msm_tunnel_id.composite.session.chunk,
+                msm_tunnel_id.composite.session.session,
+                msm_tunnel_id.composite.session.indirect,
+                msm_tunnel_id.composite.session.direction,
+                msm_tunnel_id.composite.bearer,
+                msm_int_info.sdf_id, msm_tos);
+
+    }
+
+msm_not_li:
+#endif
+
 
     msm_fab_hdr->common.qos.in_profile = IN_PROFILE_GREEN;
     msm_fab_hdr->common.qos.fc = 0x7;
