? cscope.files
? common/vendors/agere/cln90g_custom/BYPASSCAPS90NMT10W_hacked.v
? common/vendors/agere/cln90g_custom/CTCML3G3B1G1T10_hacked.v
? common/vendors/agere/cln90g_custom/DELAYLINEG1T10W_hacked.v
? common/vendors/agere/cln90g_custom/DELAYLINEG1T10W_hacked2.v
? common/vendors/agere/cln90g_custom/DELAYLINEG1T10W_hacked3.v
? common/vendors/agere/cln90g_custom/DLYLINE90nm_hacked.v
? common/vendors/agere/cln90g_custom/HSTLOSRRAIV18G8T10F_hacked.v
? common/vendors/agere/cln90g_custom/HSTLOTRBAIV18G8T10F_hacked.v
? common/vendors/agere/cln90g_custom/HSTLOTRBAIV18G8T10F_hacked2.v
? common/vendors/agere/cln90g_custom/MASTERG1T10W_hacked.v
? common/vendors/agere/cln90g_custom/MASTERG1T10W_hacked2.v
? common/vendors/agere/cln90g_custom/MASTERG1T10W_hacked3.v
? common/vendors/agere/cln90g_custom/MINDELC1G1T10W_hacked.v
? common/vendors/agere/cln90g_custom/MINDELC1G1T10W_hacked2.v
? common/vendors/agere/cln90g_custom/P6GCMU18FC_hacked.v
? common/vendors/agere/cln90g_custom/P6GCMU18FC_hacked2.v
? common/vendors/agere/cln90g_custom/P6GRXTX18FC_hacked.v
? common/vendors/agere/cln90g_custom/PLLCSPQV18G8T10_hacked.v
? npchip/sim
? npchip/src/agere/mdly_hacked.v
? npchip/src/agere/p2_2.v
? npchip/src/agere/p2_hacked.v
? npchip/src/agere/p2_model.v
? npchip/src/agere/p2_real.v
? npchip/src/agere/p2_serdes_2.v
? npchip/src/agere/p2_serdes_2_2.v
? npchip/src/agere/p2_serdes_model.v
? npchip/src/agere/p2_serdes_real.v
? npchip/src/vendors/virage/asap512d1p_1024x48cm4sw0.v.hacked
? npchip/src/vendors/virage/asap512d1p_1024x8cm4sw0.v.hacked
? npchip/src/vendors/virage/asap512d2p_1024x34cm4sw0.v.hacked
? npchip/src/vendors/virage/asap512s2p_10240x18cm16sw0.v.hacked
? npchip/src/vendors/virage/asaprfsd2p_128x132cm1sw0.v.hacked
? npchip/src/vendors/virage/asaprfsd2p_128x144cm1sw0.v.hacked
? npchip/src/vendors/virage/asaprfsd2p_256x144cm2sw0.v.hacked
? npchip/src/vendors/virage/asaprfsd2p_32x16cm1sw1.v.hacked
? npchip/src/vendors/virage/asaprfsd2p_32x93cm1sw1.v.hacked
? npchip/src/vendors/virage/asaprfsd2p_384x66cm2sw0.v.hacked
? npchip/src/vendors/virage/asaprfsd2p_384x72cm2sw0.v.hacked
? npchip/src/vendors/virage/asaprfsd2p_96x64cm1sw1.v.hacked
? npchip/src/vendors/virage/star08md1p_10240x32cm16sw0bk2_p.v.hacked
? npchip/src/vendors/virage/star08md1p_2048x288cm4sw1bk2_p.v.hacked
? npchip/src/vendors/virage/star08md1p_4096x144cm8sw1bk1_p.v.hacked
? npchip/src/vendors/virage/star08md1p_4096x288cm4sw1bk2_p.v.hacked
? npchip/src/vendors/virage/star512s1p_1024x52cm8sw0_p.v.hacked
? npchip/tb/assembler/npasm.linux
? npchip/tb/assembler/work.linux
? npchip/tb/auto/gen/lava_ingress.tstl2
? npchip/tb/main/npchip.tpd
? pchip/tb/tests/iom/ingress/.ingress_base.h.swp
? pchip/tb/tests/iom/ingress/.ingress_frames.cpp.swp
? pchip/tb/tests/iom/ingress/.ingress_ip.h.swp
? pchip/tb/tests/iom/ingress/.ingress_main.cpp.swp
? pchip/tb/tests/iom/ingress/.ingress_svc.h.swp
? pchip/tb/tests/iom/ingress/.ingress_tables.cpp.swp
? q2chip/src/packages/q2_headers.vhdl
Index: common/scripts/unix/setup.bash
===================================================================
RCS file: /hwcvs/vhdl/common/scripts/unix/setup.bash,v
retrieving revision 1.28
diff -r1.28 setup.bash
257a258,259
> echo $SCRIPTS
> 
259c261,262
<   for perlscript in $(/bin/ls ${SCRIPTS}/${dir} | grep .*\.pl | grep -v "^syn.\|^get.\|which.pl\|^put.\|^v.\|download.pl" | cut -d"." -f1); do
---
> echo $dir
>   for perlscript in $(/bin/ls ${SCRIPTS}/${dir} | grep ".*\.pl" | grep -v "^syn.\|^get.\|which.pl\|^put.\|^v.\|download.pl" | cut -d"." -f1); do
Index: pchip/scripts/testbench_scripts/run_suite.sh
===================================================================
RCS file: /hwcvs/vhdl/pchip/scripts/testbench_scripts/run_suite.sh,v
retrieving revision 1.5.2.1
diff -r1.5.2.1 run_suite.sh
44c44,45
< source ~/.bashrc
---
> #source ~/.bashrc
> source ~/.zshrc
Index: pchip/tb/tests/iom/ingress/ingress_base.h
===================================================================
RCS file: /hwcvs/vhdl/pchip/tb/tests/iom/ingress/ingress_base.h,v
retrieving revision 1.105.2.18
diff -r1.105.2.18 ingress_base.h
173a174,178
> #define EXTRACT_BITS_32(element, rshift, bitwidth)  (UINT32) (((element) >> (rshift)) & ((1 << (bitwidth)) - 1))
> // Get chunk id 
> //#define GET_CHUNK_ID(x) (UINT32)((x >> (32 - MSM_CHUNK_ID__BITS)) & ((1 << MSM_CHUNK_ID__BITS) -1))
> #define GET_CHUNK_ID(x) EXTRACT_BITS_32(x, MSM_SESSION_BEARER_ID__BITS, MSM_CHUNK_ID__BITS)
> 
183a189,190
>     INGRESS_MSM_TEST_BENCH_TYPE_L2TP_CTRL   = 7,
>     INGRESS_MSM_TEST_BENCH_TYPE_L2TP_MSM    = 8,
Index: pchip/tb/tests/iom/ingress/ingress_frames.cpp
===================================================================
RCS file: /hwcvs/vhdl/pchip/tb/tests/iom/ingress/ingress_frames.cpp,v
retrieving revision 1.1372.2.49
diff -r1.1372.2.49 ingress_frames.cpp
1428a1429
>         logpf ("%s called\n", __FUNCTION__);
1705c1706
< void add_l2tp_headers(Frame *frame, L2TP_TUNNEL_ID l2tp_tunnel_id, L2TP_SESSION_ID l2tp_session_id)
---
> void add_l2tp_headers(Frame *frame, L2TP_TUNNEL_ID l2tp_tunnel_id, L2TP_SESSION_ID l2tp_session_id, bool both_l2tp)
1710a1712,1714
>     if (both_l2tp)
>         udp_hdr.ports.source = UDP_PORT_L2TP;
>     else
1833c1837
<             add_l2tp_headers(frame, l2tp_tunnel_id, l2tp_session_id);
---
>             add_l2tp_headers(frame, l2tp_tunnel_id, l2tp_session_id, 0);
3691c3695,3696
<                        DCPU_INFO * dcpu_info = NULL)
---
>                        DCPU_INFO * dcpu_info = NULL,
>                        INGRESS_MSM_TEST_BENCH_TYPE msm_tb_type = INGRESS_MSM_TEST_BENCH_TYPE_NONE)
3698a3704
>     logpf("%s: cpm_reason: %d, msm_tb_type: %d\n", __FUNCTION__, reason, msm_tb_type);
3731c3737
<     if (is_ip_reason_code(reason))
---
>     if (is_ip_reason_code(reason) || msm_tb_type == INGRESS_MSM_TEST_BENCH_TYPE_L2TP_CTRL)
4088c4094
<         if ((msm_tb_type == INGRESS_MSM_TEST_BENCH_TYPE_IP_IN_IP) || (msm_tb_type == INGRESS_MSM_TEST_BENCH_TYPE_SSG_UL)) // add direction bit
---
>         if ((msm_tb_type == INGRESS_MSM_TEST_BENCH_TYPE_IP_IN_IP) || (msm_tb_type == INGRESS_MSM_TEST_BENCH_TYPE_SSG_UL) || (msm_tb_type == INGRESS_MSM_TEST_BENCH_TYPE_L2TP_MSM)) // add direction bit
4101a4108,4114
>             else if (msm_tb_type == INGRESS_MSM_TEST_BENCH_TYPE_L2TP_MSM)
>             {
>             sw_fabric_header.parm.raw.main.to_msm.tunnel_id = tunnel_id;
>             sw_fabric_header.parm.raw.main.to_msm.tunnel_id &= ~(((1 << MSM_CHUNK_TASK_ID__BITS) - 1) << MSM_SESSION_BEARER_ID__BITS);
>             sw_fabric_header.parm.raw.main.to_msm.sess_ip_offset = sess_ip_offset;
>             sw_fabric_header.parm.raw.main.to_msm.micronet_id = micronet_id;
>             }
16241c16254,16283
<         if ((udpDp == UDP_PORT_L2TP) && dest_sub && get_l2tp_subnet())
---
>         if ((udpDp == UDP_PORT_L2TP) && (dest_sub) && ((msm_tb_type == INGRESS_MSM_TEST_BENCH_TYPE_L2TP_CTRL) || (msm_tb_type == INGRESS_MSM_TEST_BENCH_TYPE_L2TP_MSM)))
>             {
>             logpf("%s: Calling add_l2tp_headers: 0x%x, 0x%x\n", __FUNCTION__, dest_sub->get_l2tp_tunnel_id(), dest_sub->get_l2tp_session_id());
>             add_l2tp_headers(frame, dest_sub->get_l2tp_tunnel_id(), dest_sub->get_l2tp_session_id(), 1);
>             if ((l2tp_flags == L2TP_SET_CTRL_BIT_AND_OPTS) || (l2tp_flags == L2TP_SET_CTRL_BIT) || (l2tp_flags == L2TP_IP_HDR_HAS_OPTIONS))
>                 {
>                 dest_sub = NULL;
>                 cpm_type = TO_CPM_RAW_REASON_L2TP_CONTROL;
>                 logpf("cpm_type = TO_CPM_RAW_REASON_L2TP_CONTROL\n");
>                 }
>             else
>                 no_icmp = 1;
>             if (l2tp_flags == L2TP_NORMAL)
>                 {
>                     if (msm_tb_type == INGRESS_MSM_TEST_BENCH_TYPE_L2TP_CTRL)
>                        {
>                        *frame += new PPP_Protocol_Id(PPP_PROTOCOL_IS_CONTROL | PPP_PROTOCOL_IPV4);
>                        //*frame += new IPV4_Hdr();
>                        cpm_type = TO_CPM_RAW_REASON_PPPOE_CONTROL;
>                        }
>                     else if (msm_tb_type == INGRESS_MSM_TEST_BENCH_TYPE_L2TP_MSM)
>                        {
>                        *frame += new PPP_Protocol_Id(PPP_PROTOCOL_IPV4);
>                        *frame += new IPV4_Hdr();
>                        msm_chunk_id = GET_CHUNK_ID(dest_sub->get_l2tp_tunnel_id());
>                        }
>                 }
>             if (force_error == FORCE_ERROR_TTL_EXPIRED) force_error = FORCE_ERROR_NONE;
>             }
>         else if ((udpDp == UDP_PORT_L2TP) && dest_sub && get_l2tp_subnet())
16243c16285,16286
<             add_l2tp_headers(frame, dest_sub->get_l2tp_tunnel_id(), dest_sub->get_l2tp_session_id());
---
>             logpf("%s: Calling add_l2tp_headers: 0x%x, 0x%x\n", __FUNCTION__, dest_sub->get_l2tp_tunnel_id(), dest_sub->get_l2tp_session_id());
>             add_l2tp_headers(frame, dest_sub->get_l2tp_tunnel_id(), dest_sub->get_l2tp_session_id(), 0);
16783a16827,16828
>             else if (msm_tb_type == INGRESS_MSM_TEST_BENCH_TYPE_L2TP_MSM) // assuming this can only happen for ip_in_ip case
>                 strcpy(comment, "L2TP_OR_EXT frame to MSM DATA");
16962a17008,17011
>                 logpf ("Calling remove_l2_hdrs_for_ip\n");
>                 if (msm_tb_type == INGRESS_MSM_TEST_BENCH_TYPE_L2TP_MSM)
>             remove_l2_hdrs_for_ip(msm_frame, port, false, true, false, true, true);
>                 else
17576a17626
>         logpf("TunnelId=0x%08x Hash (pre_ecmp_chv)  0x%08x\n", msm_tunnel_id, pre_ecmp_chv);
17581a17632
>     logpf("TunnelId=0x%08x Hash (pre_ecmp_chv)  0x%08x\n", msm_tunnel_id, pre_ecmp_chv);
17764c17815
<     if (dest_sub && dest_sub->sub_get_global_subscriber_id() && !dest_sub->get_redirect_if() && dest_sub->ipsec_do_alt_hash() /* true for non-ipsec */)
---
>     if (dest_sub && dest_sub->sub_get_global_subscriber_id() && !dest_sub->get_redirect_if() && dest_sub->ipsec_do_alt_hash() /* true for non-ipsec */ && (msm_tb_type != INGRESS_MSM_TEST_BENCH_TYPE_L2TP_MSM))
18357c18408
<         copy_frame_to_cpm(port, cpm_frame, correlator, cpm_type, sap_qos.fab_hdr_fc, &cpm_parms, &cpm_extra_parms, false, is_sap, false, &dcpu_info);
---
>         copy_frame_to_cpm(port, cpm_frame, correlator, cpm_type, sap_qos.fab_hdr_fc, &cpm_parms, &cpm_extra_parms, false, is_sap, false, &dcpu_info, msm_tb_type);
18412c18463
<     if (dest_sub && ((dest_sub->is_l2tp_sub() && !dest_sub->is_l2tp_lns_sub()) || dest_sub->is_gtp_sub()))
---
>     if (dest_sub && ((dest_sub->is_l2tp_sub() && !dest_sub->is_l2tp_lns_sub()) || dest_sub->is_gtp_sub()) && msm_tb_type != INGRESS_MSM_TEST_BENCH_TYPE_L2TP_MSM)
18416a18468
>         logpf("if (dest_sub && \n");
18513a18566,18577
>         else if (msm_tb_type == INGRESS_MSM_TEST_BENCH_TYPE_L2TP_MSM)
>             {
>             IPV4_Hdr * ipv4 = dynamic_cast<IPV4_Hdr *>(msm_frame->get_next_segment_by_name(FR_SEGMENT_IPV4_HDR));
>             assert(ipv4);
>             tos = ipv4->get_tos();
>             logpf ("tos: 0x%x, 0x%x\n", tos, ipv4->get_tos());
>             l4_offset = 0;
>             //l4_offset = find_offset_of_udp_or_gre_hdr(msm_frame, msm_type);
>             sess_ip_offset = 10;
>             logpf("Data packets IP Offset %d L4 offset %d tos 0x%02x, sess_ip_offset: %d\n", ip_offset, l4_offset, tos, sess_ip_offset);
>             msm_frame->delete_subframe(FR_SEGMENT_IPV4_HDR, false); // only delete first IPv4 header
>             }
18560c18624
<         logpf("To MSM hash gives %#x\n", hash_label);
---
>         logpf("To MSM hash gives %#x, %#x, %#x\n", hash_label, ecmp_chv, tunnel_chv);
22644a22709,22799
> void L3_SAP::l3_sap_build_test_frame_for_l2tp_mg_subscriber(SUBSCRIBER_BASE * sub, L3_SVC * retail_svc, ROUTING_TABLE_ENTRY * rte, SUBSCRIBER_BASE * src_sub, UINT16 filter_list_test, TO_MSM_REASON msm_type, SUBSCRIBER_BASE * src_alt_sub, UINT16 cpm_type, INGRESS_MSM_TEST_BENCH_TYPE msm_tb_type)
>     {
>     MAC_ADDR src_mac = MAC_ADDR(zero_sa);
>     PPPOE_SESSION_ID sess_id = 0;
>     UINT16 udpDp = UDP_PORT_L2TP;
> 
>     VRF_ID test_vrf = retail_svc ? retail_svc->get_vrf_id() : vrf_id;
>     if (sub)                          // either specify destination subscriber or the destination rte
>         {
>         assert(!rte);
>         rte = sub->get_rte();
>         }
>     assert(rte);
> 
>     IPV4_ROUTING_TABLE_ENTRY *ipv4_rte = dynamic_cast<IPV4_ROUTING_TABLE_ENTRY *>(rte);
>     IPV6_ROUTING_TABLE_ENTRY *ipv6_rte = dynamic_cast<IPV6_ROUTING_TABLE_ENTRY *>(rte);
> 
>     if (!src_sub && sub_entries.size())
>         {
>         if (ipv4_rte)
>             src_sub = get_first_v4_subscriber();
> #if (NPCHIP == 1)
>         else
>             src_sub = get_first_v6_subscriber();
> #endif
>         }
>     if (src_sub)
>         {
>         src_mac = src_sub->get_mac_sa();
>         if ((force_error == FORCE_ERROR_DUPLICATE_SUB_APP_INDEX) && sub)
>             sess_id = sub->get_pppoe_sess_id();
>         else
>             sess_id = src_sub->get_pppoe_sess_id();
>         if ((force_error == FORCE_ERROR_ANTI_SPOOF) && !src_sub->sub_uses_ip_antispoof())
>             src_mac.mac.b[5] ^= 1;
>         }
>     Frame * incoming_mac_hdr = intf_build_layer2_header(get_ingress_phys_port(), src_mac, ipv6_rte ? INTF_FRAME_TYPE_IPV6 : INTF_FRAME_TYPE_IPV4, NULL, sess_id);
> 
>     UINT32 fr_len;
>     if (sub_entries.size())
>         {
>         if (ipv4_rte)
>             {
>             IPV4_SUBSCRIBER *ipv4_src_sub = dynamic_cast<IPV4_SUBSCRIBER *>(src_sub);
>             assert(ipv4_src_sub);
>             IPV4_SUBSCRIBER *ipv4_sub = dynamic_cast<IPV4_SUBSCRIBER *>(sub);
>             IP_ADDR src_ip = ipv4_src_sub->get_ip_addr();
>             if (force_error == FORCE_ERROR_ANTI_SPOOF)
>                 src_ip.ip.b[3] ^= 1;
>             fr_len = ipv4_rte->v4_rte_build_routing_dest_test_frame(incoming_mac_hdr, test_vrf, src_ip, this, false, NULL,
>                                                                     udpDp, cpm_type, msm_type, ipv4_sub, src_alt_sub ? src_alt_sub : ipv4_src_sub, NULL, false, false, NULL, NULL, NULL, msm_tb_type);    // src_alt_sub used for v4 NAT w/ v6 with MAC antispoof
>             }
>         else
>             {
> #if (NPCHIP == 1)
>             IPV6_SUBSCRIBER *ipv6_src_sub = dynamic_cast<IPV6_SUBSCRIBER *>(src_sub);
>             assert(ipv6_src_sub);
>             IPV6_SUBSCRIBER *ipv6_sub = dynamic_cast<IPV6_SUBSCRIBER *>(sub);
> 
>             fr_len = ipv6_rte->v6_rte_build_routing_dest_test_frame(incoming_mac_hdr, test_vrf, 
>                                                                     ipv6_src_sub->get_ipv6_addr_and_set_host_bits(/*rand_host_bits*/true, /*make_bad_subnet*/force_error == FORCE_ERROR_ANTI_SPOOF),
>                                                                     this, /*vprn_from_network*/false, /*igp_shortcut_lsp*/NULL,
>                                                                     udpDp, /*cpm_frame_type*/cpm_type, msm_type, filter_list_test, ipv6_sub, src_alt_sub ? src_alt_sub : ipv6_src_sub);
> #endif
>             }
>         }
>     else
>         {
>         if (ipv4_rte)
>             {
>             IPV4_SUBSCRIBER *ipv4_sub = dynamic_cast<IPV4_SUBSCRIBER *>(sub);
> 
>             fr_len = ipv4_rte->v4_rte_build_routing_dest_test_frame(incoming_mac_hdr, test_vrf, this,
>                             /*vprn_from_network*/ false, /*igp_shortcut_lsp*/ NULL, 
>                             udpDp, /*cpm_frame_type*/ cpm_type, msm_type, ipv4_sub, NULL, NULL, false, false, NULL, msm_tb_type); 
>             }
>         else
>             fr_len = ipv6_rte->v6_rte_build_routing_dest_test_frame(incoming_mac_hdr, test_vrf, this, false, NULL, 0, cpm_type, msm_type, filter_list_test, sub);
>         }
> 
>     if (fr_len & FRAME_WAS_DROPPED_FLAG_LEN)
>         {
>         if (force_error != FORCE_ERROR_ENCAP_INVALID)
>             add_expected_drop(fr_len & 0xffff);
>         }
>     else if (fr_len)
>         {
>         add_expected_frame(fr_len);
>         }
>     }
> 
22960a23116,23161
> #endif
>     }
> 
> void LOCAL_SUBNET::subnet_build_subscriber_frames_for_l2tp_mg(L3_SAP * sap, L3_SVC * retail_svc)
>     {
>     UINT32 fr_cnt = 1;
>     for (list<SUBSCRIBER_BASE *>::iterator ptr = subscribers.begin(); ptr != subscribers.end(); ptr++)
>         {
>         SUBSCRIBER_BASE *sub = *ptr;
>         //sap->l3_sap_build_test_frame_for_subscriber(sub, retail_svc);
>         logpf ("L2TP MG subs - Frame: %d\n", fr_cnt++);
>         sap->l3_sap_build_test_frame_for_l2tp_mg_subscriber(sub, retail_svc, NULL, NULL, IP_FLT_TEST_INVALID, 0, NULL, TO_CPM_RAW_REASON_PPPOE_CONTROL, INGRESS_MSM_TEST_BENCH_TYPE_L2TP_CTRL);
>         logpf ("L2TP MG subs - Frame: %d\n", fr_cnt++);
>         sap->l3_sap_build_test_frame_for_l2tp_mg_subscriber(sub, retail_svc, NULL, NULL, IP_FLT_TEST_INVALID, TO_MSM_REASON_L2TP_OR_EXT, NULL, 0, INGRESS_MSM_TEST_BENCH_TYPE_L2TP_MSM);
> 
> #if 0
>         if (sub->is_l2tp_sub() && !sub->is_unreachable() && !sent_l2tp_variants)
>             {
>                 logpf("sub->is_l2tp_sub()\n");
>             l2tp_flags = L2TP_SET_CTRL_BIT;
>             sap->l3_sap_build_test_frame_for_subscriber(sub, retail_svc);
>             l2tp_flags = L2TP_ADD_LENGTH_OPT;
>             sap->l3_sap_build_test_frame_for_subscriber(sub, retail_svc);
> 
>             l2tp_flags = L2TP_ADD_OFFSET_OPT;
>             sap->l3_sap_build_test_frame_for_subscriber(sub, retail_svc);
>             l2tp_flags = L2TP_ADD_SEQUENCE_OPTS;
>             sap->l3_sap_build_test_frame_for_subscriber(sub, retail_svc);
>             l2tp_flags = L2TP_ADD_LENGTH_OFFSET_AND_SEQUENCE_OPTS;
>             sap->l3_sap_build_test_frame_for_subscriber(sub, retail_svc);
>             l2tp_flags = L2TP_SET_CTRL_BIT_AND_OPTS;
>             sap->l3_sap_build_test_frame_for_subscriber(sub, retail_svc);
> 
>             l2tp_flags = L2TP_IP_HDR_HAS_OPTIONS;
>             sap->l3_sap_build_test_frame_for_subscriber(sub, retail_svc);
> 
>             l2tp_flags = L2TP_NORMAL;
>             }
> #endif
>         }
> #if 0
> #ifdef FORCE_ERRORS
>     force_error = FORCE_ERROR_TTL_EXPIRED;
>     sap->l3_sap_build_test_frame_for_subscriber(*(subscribers.begin()), retail_svc);
>     force_error = FORCE_ERROR_NONE;
> #endif
Index: pchip/tb/tests/iom/ingress/ingress_ip.h
===================================================================
RCS file: /hwcvs/vhdl/pchip/tb/tests/iom/ingress/ingress_ip.h,v
retrieving revision 1.256.2.12
diff -r1.256.2.12 ingress_ip.h
774a775
>     void                        subnet_build_subscriber_frames_for_l2tp_mg(L3_SAP * sap, L3_SVC * retail = NULL);
Index: pchip/tb/tests/iom/ingress/ingress_main.cpp
===================================================================
RCS file: /hwcvs/vhdl/pchip/tb/tests/iom/ingress/ingress_main.cpp,v
retrieving revision 1.1260.2.39
diff -r1.1260.2.39 ingress_main.cpp
9108a9109,9123
>     logpf("Start L2TP MG subs\n");
> 
>     VPRN sub_mgmt_vprn3;
>     L3_SAP sub_mgmt_vprn_sap9 (&sub_mgmt_vprn3, &port0eq);
>     sub_mgmt_vprn_sap9.set_ip(IP_ADDR(33, 1, 1, 1), 24);
> 
>     LOCAL_SUBNET * vs7_subnet = sub_mgmt_vprn_sap9.get_subnet();
>     vs7_subnet->set_is_l2tp_subnet();
>     IPV4_ROUTING_TABLE_ENTRY * vs7_rte = add_host_subnet (&sub_mgmt_vprn_sap9, &sub_mgmt_vprn3, false);
> 
>     IPV4_SUBSCRIBER vprn1_sub17 (RAND_MAC, IP_ADDR(33, 1, 1, 1), next_pppoe_sess_id++, SUB_QUEUE_NORMAL);  // PPPoE
>     vprn1_sub17.bind_to_l2tp_mg_subnet(vs7_subnet, &sub_mgmt_vprn_sap9, vs7_rte, &vprn_sub_spoke2);
> 
>     logpf("Done L2TP MG subs\n");
> 
13182a13198,13202
> 
>         SET_FRAME_PHASE("L2TP MG LAC");
>         logpf("Start L2TP MG subs - building frames\n");
>         vs7_subnet->subnet_build_subscriber_frames_for_l2tp_mg(&sub_mgmt_vprn_sap9);
>         logpf("Done L2TP MG subs - building frames\n");
Index: pchip/tb/tests/iom/ingress/ingress_svc.h
===================================================================
RCS file: /hwcvs/vhdl/pchip/tb/tests/iom/ingress/ingress_svc.h,v
retrieving revision 1.373.2.5
diff -r1.373.2.5 ingress_svc.h
1372a1373
>     void                    l3_sap_build_test_frame_for_l2tp_mg_subscriber(SUBSCRIBER_BASE * sub, L3_SVC * retail = NULL, ROUTING_TABLE_ENTRY * rte = NULL, SUBSCRIBER_BASE * src_sub = NULL, UINT16 filter_list_test = IP_FLT_TEST_INVALID, TO_MSM_REASON msm_type = 0, SUBSCRIBER_BASE * src_alt_sub = NULL, UINT16 cpm_type = 0, INGRESS_MSM_TEST_BENCH_TYPE msm_tb_type = INGRESS_MSM_TEST_BENCH_TYPE_NONE);
1373a1375
>     void                    l3_sap_build_l2tp_test_frame_for_subscriber(SUBSCRIBER_BASE * src_sub, ROUTING_TABLE_ENTRY * rte = NULL);
1660a1663
>     bool                            is_l2tp_mg() const { return l2tp_mg; }
1715a1719
>     bool                            l2tp_mg;
1762a1767
>     void                            bind_to_l2tp_mg_subnet(LOCAL_SUBNET * sub, SAP_ENDPOINT * dest_sap, IPV4_ROUTING_TABLE_ENTRY *rte, L3_SDP_ENDPOINT *src_ep);
Index: pchip/tb/tests/iom/ingress/ingress_tables.cpp
===================================================================
RCS file: /hwcvs/vhdl/pchip/tb/tests/iom/ingress/ingress_tables.cpp,v
retrieving revision 1.1224.2.27
diff -r1.1224.2.27 ingress_tables.cpp
26a27
> //
12988a12990,12991
>         rec->is_l2tp_mg = is_l2tp_mg();
>         logpf("rec->is_lac: %d, is_l2tp_mg: %d, is_l2tp_lns_sub: %d, is_l2tp_sub: %d, is_gtp_sub: %d, !lns_sub && l2tp_sub: %d\n", rec->is_lac, rec->is_l2tp_mg, is_l2tp_lns_sub(), is_l2tp_sub(), is_gtp_sub(), (!is_l2tp_lns_sub() && is_l2tp_sub()));
12998a13002,13007
>         logpf("msm_chunk_id: 0x%x (%d), tun_id: 0x%x, (%d)\n", rec->msm_chunk_id, rec->msm_chunk_id, get_l2tp_tunnel_id(), get_l2tp_tunnel_id());
>         if (rec->is_l2tp_mg) {
>             rec->dest_sap_index = 0;
>             rec->msm_chunk_id = GET_CHUNK_ID(get_l2tp_tunnel_id());
>         }
>         logpf("msm_chunk_id: 0x%x (%d), tun_id: 0x%x, (%d)\n", rec->msm_chunk_id, rec->msm_chunk_id, get_l2tp_tunnel_id(), get_l2tp_tunnel_id());
13529a13539,13568
> 
>     assert(ds);
> 
> #if (NPCHIP == 0)
>     INGRESS_SUB_NEXTHOP_LOOKUP_KEY key = {};
>     INGRESS_SUB_NEXTHOP_RECORD rec = {};
>     fill_in_sub_nexthop_recs(&key, &rec, NULL);
>     hash_INGRESS_SUB_NEXTHOP->add_entry(&rec, &key, sub_host_index, NULL, this, extra_hash_chain_entries);
> #else
>     INGRESS_NP_SUB_NEXTHOP_LOOKUP_KEY key = {};
>     INGRESS_NP_SUB_NEXTHOP_RECORD rec = {};
>     fill_in_sub_nexthop_recs(&key, &rec, NULL);
>     hash_INGRESS_NP_SUB_NEXTHOP->add_entry(&rec, &key, sub_host_index, NULL, this, extra_hash_chain_entries);
>     logpf("writing ingress tables for %s lns subscriber tunnel_in=0x%x session_id=%u\n", subnet->get_is_l2tp_subnet() ? "L2TP" : "GTP", key.l2tp.tunnel_id, key.l2tp.session_id);
> #endif
>     }
> 
> void IPV4_SUBSCRIBER::bind_to_l2tp_mg_subnet(LOCAL_SUBNET * sub, SAP_ENDPOINT * ds, IPV4_ROUTING_TABLE_ENTRY *rte, L3_SDP_ENDPOINT *src_ep)
>     {
>     subnet = sub;
>     dest_sap = ds;
>     this->rte = rte;
>     this->redirect_if = NULL;
>     dest_sap_is_down = false;
>     send_using_vrrp_src_mac = false;
>     this->l2tp_mg = true;//is_l2tp_mg;
> 
>     subnet->add_subscriber(this);
>     l2tp_tunnel_id = src_ep->get_l2tp_tunnel_id();
>     set_l2tp_session_id();
