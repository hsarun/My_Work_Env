Index: scripts/testbench_scripts/run_suite.sh
===================================================================
RCS file: /hwcvs/vhdl/pchip/scripts/testbench_scripts/run_suite.sh,v
retrieving revision 1.5.2.1
diff -r1.5.2.1 run_suite.sh
44c44,45
< source ~/.bashrc
---
> #source ~/.bashrc
> source ~/.zshrc
Index: tb/tests/iom/ingress/ingress_base.h
===================================================================
RCS file: /hwcvs/vhdl/pchip/tb/tests/iom/ingress/ingress_base.h,v
retrieving revision 1.105.2.18
diff -r1.105.2.18 ingress_base.h
183a184
>     INGRESS_MSM_TEST_BENCH_TYPE_L2TP_CTRL   = 7,
Index: tb/tests/iom/ingress/ingress_frames.cpp
===================================================================
RCS file: /hwcvs/vhdl/pchip/tb/tests/iom/ingress/ingress_frames.cpp,v
retrieving revision 1.1372.2.49
diff -r1.1372.2.49 ingress_frames.cpp
1705c1705
< void add_l2tp_headers(Frame *frame, L2TP_TUNNEL_ID l2tp_tunnel_id, L2TP_SESSION_ID l2tp_session_id)
---
> void add_l2tp_headers(Frame *frame, L2TP_TUNNEL_ID l2tp_tunnel_id, L2TP_SESSION_ID l2tp_session_id, bool both_l2tp)
1710a1711,1713
>     if (both_l2tp)
>         udp_hdr.ports.source = UDP_PORT_L2TP;
>     else
1833c1836
<             add_l2tp_headers(frame, l2tp_tunnel_id, l2tp_session_id);
---
>             add_l2tp_headers(frame, l2tp_tunnel_id, l2tp_session_id, 0);
3691c3694,3695
<                        DCPU_INFO * dcpu_info = NULL)
---
>                        DCPU_INFO * dcpu_info = NULL,
>                        INGRESS_MSM_TEST_BENCH_TYPE msm_tb_type = INGRESS_MSM_TEST_BENCH_TYPE_NONE)
3698a3703
>     logpf("%s: cpm_reason: %d, msm_tb_type: %d\n", __FUNCTION__, reason, msm_tb_type);
3731c3736
<     if (is_ip_reason_code(reason))
---
>     if (is_ip_reason_code(reason) || msm_tb_type == INGRESS_MSM_TEST_BENCH_TYPE_L2TP_CTRL)
16241c16246,16267
<         if ((udpDp == UDP_PORT_L2TP) && dest_sub && get_l2tp_subnet())
---
>         if ((udpDp == UDP_PORT_L2TP) && (dest_sub) && (msm_tb_type == INGRESS_MSM_TEST_BENCH_TYPE_L2TP_CTRL))
>             {
>             logpf("%s: Calling add_l2tp_headers: 0x%x, 0x%x\n", __FUNCTION__, dest_sub->get_l2tp_tunnel_id(), dest_sub->get_l2tp_session_id());
>             add_l2tp_headers(frame, dest_sub->get_l2tp_tunnel_id(), dest_sub->get_l2tp_session_id(), 1);
>             if ((l2tp_flags == L2TP_SET_CTRL_BIT_AND_OPTS) || (l2tp_flags == L2TP_SET_CTRL_BIT) || (l2tp_flags == L2TP_IP_HDR_HAS_OPTIONS))
>                 {
>                 dest_sub = NULL;
>                 cpm_type = TO_CPM_RAW_REASON_L2TP_CONTROL;
>                 logpf("cpm_type = TO_CPM_RAW_REASON_L2TP_CONTROL\n");
>                 }
>             else
>                 no_icmp = 1;
>             if (l2tp_flags == L2TP_NORMAL)
>                 {
>                 // add some random payload
>                     *frame += new PPP_Protocol_Id(PPP_PROTOCOL_IS_CONTROL | PPP_PROTOCOL_IPV4);
>                     //*frame += new IPV4_Hdr();
>                     cpm_type = TO_CPM_RAW_REASON_PPPOE_CONTROL;
>                 }
>             if (force_error == FORCE_ERROR_TTL_EXPIRED) force_error = FORCE_ERROR_NONE;
>             }
>         else if ((udpDp == UDP_PORT_L2TP) && dest_sub && get_l2tp_subnet())
16243c16269,16270
<             add_l2tp_headers(frame, dest_sub->get_l2tp_tunnel_id(), dest_sub->get_l2tp_session_id());
---
>             logpf("%s: Calling add_l2tp_headers: 0x%x, 0x%x\n", __FUNCTION__, dest_sub->get_l2tp_tunnel_id(), dest_sub->get_l2tp_session_id());
>             add_l2tp_headers(frame, dest_sub->get_l2tp_tunnel_id(), dest_sub->get_l2tp_session_id(), 0);
18357c18384
<         copy_frame_to_cpm(port, cpm_frame, correlator, cpm_type, sap_qos.fab_hdr_fc, &cpm_parms, &cpm_extra_parms, false, is_sap, false, &dcpu_info);
---
>         copy_frame_to_cpm(port, cpm_frame, correlator, cpm_type, sap_qos.fab_hdr_fc, &cpm_parms, &cpm_extra_parms, false, is_sap, false, &dcpu_info, msm_tb_type);
22644a22672,22764
> void L3_SAP::l3_sap_build_test_frame_for_l2tp_mg_subscriber(SUBSCRIBER_BASE * sub, L3_SVC * retail_svc, ROUTING_TABLE_ENTRY * rte, SUBSCRIBER_BASE * src_sub, UINT16 filter_list_test, TO_MSM_REASON msm_type, SUBSCRIBER_BASE * src_alt_sub, UINT16 cpm_type, INGRESS_MSM_TEST_BENCH_TYPE msm_tb_type)
>     {
>     MAC_ADDR src_mac = MAC_ADDR(zero_sa);
>     PPPOE_SESSION_ID sess_id = 0;
>     UINT16 udpDp = (msm_type == TO_MSM_REASON_GTP) ? UDP_PORT_GTP_CONTROL : 0;
> 
>     VRF_ID test_vrf = retail_svc ? retail_svc->get_vrf_id() : vrf_id;
>     if (sub)                          // either specify destination subscriber or the destination rte
>         {
>         assert(!rte);
>         rte = sub->get_rte();
>         }
>     assert(rte);
> 
>     IPV4_ROUTING_TABLE_ENTRY *ipv4_rte = dynamic_cast<IPV4_ROUTING_TABLE_ENTRY *>(rte);
>     IPV6_ROUTING_TABLE_ENTRY *ipv6_rte = dynamic_cast<IPV6_ROUTING_TABLE_ENTRY *>(rte);
> 
>     if (!src_sub && sub_entries.size())
>         {
>         if (ipv4_rte)
>             src_sub = get_first_v4_subscriber();
> #if (NPCHIP == 1)
>         else
>             src_sub = get_first_v6_subscriber();
> #endif
>         }
>     if (src_sub)
>         {
>         src_mac = src_sub->get_mac_sa();
>         if ((force_error == FORCE_ERROR_DUPLICATE_SUB_APP_INDEX) && sub)
>             sess_id = sub->get_pppoe_sess_id();
>         else
>             sess_id = src_sub->get_pppoe_sess_id();
>         if ((force_error == FORCE_ERROR_ANTI_SPOOF) && !src_sub->sub_uses_ip_antispoof())
>             src_mac.mac.b[5] ^= 1;
>         }
>     Frame * incoming_mac_hdr = intf_build_layer2_header(get_ingress_phys_port(), src_mac, ipv6_rte ? INTF_FRAME_TYPE_IPV6 : INTF_FRAME_TYPE_IPV4, NULL, sess_id);
>     if (rte->get_l2tp_subnet())
>         udpDp = UDP_PORT_L2TP;
> 
>     UINT32 fr_len;
>     if (sub_entries.size())
>         {
>         if (ipv4_rte)
>             {
>             IPV4_SUBSCRIBER *ipv4_src_sub = dynamic_cast<IPV4_SUBSCRIBER *>(src_sub);
>             assert(ipv4_src_sub);
>             IPV4_SUBSCRIBER *ipv4_sub = dynamic_cast<IPV4_SUBSCRIBER *>(sub);
>             IP_ADDR src_ip = ipv4_src_sub->get_ip_addr();
>             if (force_error == FORCE_ERROR_ANTI_SPOOF)
>                 src_ip.ip.b[3] ^= 1;
>             fr_len = ipv4_rte->v4_rte_build_routing_dest_test_frame(incoming_mac_hdr, test_vrf, src_ip, this, false, NULL,
>                                                                     udpDp, cpm_type, msm_type, ipv4_sub, src_alt_sub ? src_alt_sub : ipv4_src_sub, NULL, false, false, NULL, NULL, NULL, msm_tb_type);    // src_alt_sub used for v4 NAT w/ v6 with MAC antispoof
>             }
>         else
>             {
> #if (NPCHIP == 1)
>             IPV6_SUBSCRIBER *ipv6_src_sub = dynamic_cast<IPV6_SUBSCRIBER *>(src_sub);
>             assert(ipv6_src_sub);
>             IPV6_SUBSCRIBER *ipv6_sub = dynamic_cast<IPV6_SUBSCRIBER *>(sub);
> 
>             fr_len = ipv6_rte->v6_rte_build_routing_dest_test_frame(incoming_mac_hdr, test_vrf, 
>                                                                     ipv6_src_sub->get_ipv6_addr_and_set_host_bits(/*rand_host_bits*/true, /*make_bad_subnet*/force_error == FORCE_ERROR_ANTI_SPOOF),
>                                                                     this, /*vprn_from_network*/false, /*igp_shortcut_lsp*/NULL,
>                                                                     udpDp, /*cpm_frame_type*/cpm_type, msm_type, filter_list_test, ipv6_sub, src_alt_sub ? src_alt_sub : ipv6_src_sub);
> #endif
>             }
>         }
>     else
>         {
>         if (ipv4_rte)
>             {
>             IPV4_SUBSCRIBER *ipv4_sub = dynamic_cast<IPV4_SUBSCRIBER *>(sub);
> 
>             fr_len = ipv4_rte->v4_rte_build_routing_dest_test_frame(incoming_mac_hdr, test_vrf, this,
>                             /*vprn_from_network*/ false, /*igp_shortcut_lsp*/ NULL, 
>                             udpDp, /*cpm_frame_type*/ cpm_type, msm_type, ipv4_sub, NULL, NULL, false, false, NULL, msm_tb_type); 
>             }
>         else
>             fr_len = ipv6_rte->v6_rte_build_routing_dest_test_frame(incoming_mac_hdr, test_vrf, this, false, NULL, 0, cpm_type, msm_type, filter_list_test, sub);
>         }
>         
>     if (fr_len & FRAME_WAS_DROPPED_FLAG_LEN)
>         {
>         if (force_error != FORCE_ERROR_ENCAP_INVALID)
>             add_expected_drop(fr_len & 0xffff);
>         }
>     else if (fr_len)
>         {
>         add_expected_frame(fr_len);
>         }
>     }
> 
22960a23081,23124
> #endif
>     }
> 
> void LOCAL_SUBNET::subnet_build_subscriber_frames_for_l2tp_mg(L3_SAP * sap, L3_SVC * retail_svc)
>     {
>     logpf("%s: Start\n", __FUNCTION__);
>     for (list<SUBSCRIBER_BASE *>::iterator ptr = subscribers.begin(); ptr != subscribers.end(); ptr++)
>         {
>         SUBSCRIBER_BASE *sub = *ptr;
>         //sap->l3_sap_build_test_frame_for_subscriber(sub, retail_svc);
>         sap->l3_sap_build_test_frame_for_l2tp_mg_subscriber(sub, retail_svc, NULL, NULL, IP_FLT_TEST_INVALID, 0, NULL, TO_CPM_RAW_REASON_PPPOE_CONTROL, INGRESS_MSM_TEST_BENCH_TYPE_L2TP_CTRL);
> 
> #if 0
>         if (sub->is_l2tp_sub() && !sub->is_unreachable() && !sent_l2tp_variants)
>             {
>                 logpf("sub->is_l2tp_sub()\n");
>             l2tp_flags = L2TP_SET_CTRL_BIT;
>             sap->l3_sap_build_test_frame_for_subscriber(sub, retail_svc);
>             l2tp_flags = L2TP_ADD_LENGTH_OPT;
>             sap->l3_sap_build_test_frame_for_subscriber(sub, retail_svc);
> 
>             l2tp_flags = L2TP_ADD_OFFSET_OPT;
>             sap->l3_sap_build_test_frame_for_subscriber(sub, retail_svc);
>             l2tp_flags = L2TP_ADD_SEQUENCE_OPTS;
>             sap->l3_sap_build_test_frame_for_subscriber(sub, retail_svc);
>             l2tp_flags = L2TP_ADD_LENGTH_OFFSET_AND_SEQUENCE_OPTS;
>             sap->l3_sap_build_test_frame_for_subscriber(sub, retail_svc);
>             l2tp_flags = L2TP_SET_CTRL_BIT_AND_OPTS;
>             sap->l3_sap_build_test_frame_for_subscriber(sub, retail_svc);
> 
>             l2tp_flags = L2TP_IP_HDR_HAS_OPTIONS;
>             sap->l3_sap_build_test_frame_for_subscriber(sub, retail_svc);
> 
>             l2tp_flags = L2TP_NORMAL;
>             }
> #endif
>         }
> #if 0
> #ifdef FORCE_ERRORS
>     force_error = FORCE_ERROR_TTL_EXPIRED;
>     logpf("force err\n");
>     sap->l3_sap_build_test_frame_for_subscriber(*(subscribers.begin()), retail_svc);
>     force_error = FORCE_ERROR_NONE;
> #endif
Index: tb/tests/iom/ingress/ingress_ip.h
===================================================================
RCS file: /hwcvs/vhdl/pchip/tb/tests/iom/ingress/ingress_ip.h,v
retrieving revision 1.256.2.12
diff -r1.256.2.12 ingress_ip.h
774a775
>     void                        subnet_build_subscriber_frames_for_l2tp_mg(L3_SAP * sap, L3_SVC * retail = NULL);
Index: tb/tests/iom/ingress/ingress_main.cpp
===================================================================
RCS file: /hwcvs/vhdl/pchip/tb/tests/iom/ingress/ingress_main.cpp,v
retrieving revision 1.1260.2.39
diff -r1.1260.2.39 ingress_main.cpp
9108a9109,9126
>     logpf("Start New L2TP nw subs\n");
> 
>     VPRN sub_mgmt_vprn3;
>     L3_SAP sub_mgmt_vprn_sap10 (&sub_mgmt_vprn3, &port0eq);
>     //logpf("Set vrrp 0\n");
>     //sub_mgmt_vprn_sap10.get_subnet()->set_use_vrrp_ip_address(0);
>     sub_mgmt_vprn_sap10.set_ip(IP_ADDR(33, 1, 1, 1), 24);
> 
>     LOCAL_SUBNET * vs7_subnet = sub_mgmt_vprn_sap10.get_subnet();
>     vs7_subnet->set_is_l2tp_subnet();
>     IPV4_ROUTING_TABLE_ENTRY * vs8_rte = add_host_subnet (&sub_mgmt_vprn_sap10, &sub_mgmt_vprn3, false);
> 
>     IPV4_SUBSCRIBER vprn1_sub17 (RAND_MAC, IP_ADDR(33, 1, 1, 1), next_pppoe_sess_id++, SUB_QUEUE_NORMAL);  // PPPoE
>     vprn1_sub17.bind_to_l2tp_subnet(vs7_subnet, &sub_mgmt_vprn_sap10, vs8_rte, &vprn_sub_spoke2);
>     //vprn1_sub16.bind_to_l2tp(&sub_mgmt_vprn_sap9, NULL, false, true);
> 
>     logpf("Done new L2TP nw subs\n");
> 
13183a13202,13205
>         SET_FRAME_PHASE("L2TP nw LAC");
>         logpf("Start New L2TP nw subs - building frames\n");
>         vs7_subnet->subnet_build_subscriber_frames_for_l2tp_mg(&sub_mgmt_vprn_sap10);
>         logpf("Done New L2TP nw subs - building frames\n");
Index: tb/tests/iom/ingress/ingress_svc.h
===================================================================
RCS file: /hwcvs/vhdl/pchip/tb/tests/iom/ingress/ingress_svc.h,v
retrieving revision 1.373.2.5
diff -r1.373.2.5 ingress_svc.h
1372a1373
>     void                    l3_sap_build_test_frame_for_l2tp_mg_subscriber(SUBSCRIBER_BASE * sub, L3_SVC * retail = NULL, ROUTING_TABLE_ENTRY * rte = NULL, SUBSCRIBER_BASE * src_sub = NULL, UINT16 filter_list_test = IP_FLT_TEST_INVALID, TO_MSM_REASON msm_type = 0, SUBSCRIBER_BASE * src_alt_sub = NULL, UINT16 cpm_type = 0, INGRESS_MSM_TEST_BENCH_TYPE msm_tb_type = INGRESS_MSM_TEST_BENCH_TYPE_NONE);
1373a1375
>     void                    l3_sap_build_l2tp_test_frame_for_subscriber(SUBSCRIBER_BASE * src_sub, ROUTING_TABLE_ENTRY * rte = NULL);
1660a1663
>     bool                            is_l2tp_mg() const { return l2tp_mg; }
1715a1719
>     bool                            l2tp_mg;
1760a1765,1767
>                                                    IP_INTERFACE * redirect_if = NULL, bool is_lns = false, bool dest_sap_is_down = false, 
>                                                    bool send_using_vrrp = false);
>     void                            bind_to_l2tp_subnet(LOCAL_SUBNET * sub, SAP_ENDPOINT * dest_sap, IPV4_ROUTING_TABLE_ENTRY *rte, L3_SDP_ENDPOINT *src_ep,
Index: tb/tests/iom/ingress/ingress_tables.cpp
===================================================================
RCS file: /hwcvs/vhdl/pchip/tb/tests/iom/ingress/ingress_tables.cpp,v
retrieving revision 1.1224.2.27
diff -r1.1224.2.27 ingress_tables.cpp
12988a12989,12990
>         rec->is_l2tp_mg = is_l2tp_mg();
>         logpf("rec->is_lac: %d, is_l2tp_mg: %d, is_l2tp_lns_sub: %d, is_l2tp_sub: %d, is_gtp_sub: %d, !lns_sub && l2tp_sub: %d\n", rec->is_lac, rec->is_l2tp_mg, is_l2tp_lns_sub(), is_l2tp_sub(), is_gtp_sub(), (!is_l2tp_lns_sub() && is_l2tp_sub()));
13529a13532,13567
> 
>     assert(ds);
> 
> #if (NPCHIP == 0)
>     INGRESS_SUB_NEXTHOP_LOOKUP_KEY key = {};
>     INGRESS_SUB_NEXTHOP_RECORD rec = {};
>     fill_in_sub_nexthop_recs(&key, &rec, NULL);
>     hash_INGRESS_SUB_NEXTHOP->add_entry(&rec, &key, sub_host_index, NULL, this, extra_hash_chain_entries);
> #else
>     INGRESS_NP_SUB_NEXTHOP_LOOKUP_KEY key = {};
>     INGRESS_NP_SUB_NEXTHOP_RECORD rec = {};
>     fill_in_sub_nexthop_recs(&key, &rec, NULL);
>     hash_INGRESS_NP_SUB_NEXTHOP->add_entry(&rec, &key, sub_host_index, NULL, this, extra_hash_chain_entries);
>     logpf("writing ingress tables for %s lns subscriber tunnel_in=0x%x session_id=%u\n", subnet->get_is_l2tp_subnet() ? "L2TP" : "GTP", key.l2tp.tunnel_id, key.l2tp.session_id);
> #endif
>     }
> 
> void IPV4_SUBSCRIBER::bind_to_l2tp_subnet(LOCAL_SUBNET * sub, SAP_ENDPOINT * ds, IPV4_ROUTING_TABLE_ENTRY *rte, L3_SDP_ENDPOINT *src_ep, IP_INTERFACE * redirect_if, bool is_lns, bool ds_is_down, bool use_vrrp_mac)
>     {
>     subnet = sub;
>     dest_sap = ds;
>     this->rte = rte;
>     this->redirect_if = redirect_if;
>     dest_sap_is_down = ds_is_down;
>     send_using_vrrp_src_mac = use_vrrp_mac;
>     this->l2tp_mg = true;//is_l2tp_mg;
> 
>     subnet->add_subscriber(this);
> //    if (subnet->get_is_l2tp_subnet())
>         {
>         //l2tp_tunnel_id = RAND_16;
>         l2tp_tunnel_id = src_ep->get_l2tp_tunnel_id();
>         set_l2tp_session_id();
>         }
> //    else
> //        set_gtp_te_id();
