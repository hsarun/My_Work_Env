diff --git a/iom/iom_hash_tbl.h b/iom/iom_hash_tbl.h
index 6378086..d3df2b9 100644
--- a/iom/iom_hash_tbl.h
+++ b/iom/iom_hash_tbl.h
@@ -519,6 +519,10 @@ void np_hash_##name##_TABLE::np_write_initial_table(NP_HASH_BUCKET_DATA * bucket
             (iom_has_vfp ? CONSTRUCT_VFP_HASH_TABLE (cplx, chain, name,  k2mode, rafn, ppm)                 \
                          : CONSTRUCT_ANY_HASH_TABLE(cplx, chain, name, k2mode, rafn, thfn, ppm, sync))
 
+#define CONSTRUCT_HASH_TABLE_COM_INC_VFP(cplx, chain, name, rafn, thfn, ppm)                                \
+            (iom_has_vfp ? CONSTRUCT_VFP_HASH_TABLE(cplx, chain, name, true, rafn, ppm)                     \
+                         : CONSTRUCT_HASH_TABLE_COM(cplx, chain, name, rafn, thfn, ppm))
+
 #define CONSTRUCT_NP_VFP_HASH_TABLE(cplx, chain, name, rafn, thfn, ppm)                                     \
             (iom_has_vfp ? CONSTRUCT_VFP_HASH_TABLE (cplx, chain, name,  false, rafn, ppm)                  \
                          : CONSTRUCT_NP_HASH_TABLE(cplx, chain, name, false, rafn, thfn, ppm, false))
diff --git a/iom/iom_main.cpp b/iom/iom_main.cpp
index c6ac28d..5ab1986 100644
--- a/iom/iom_main.cpp
+++ b/iom/iom_main.cpp
@@ -4306,7 +4306,8 @@ bool IOM_COMPLEX::initialize_complex (tHwMdaType hw_mda_type)
     INGRESS_DEST_AND_Q_hash_table = CONSTRUCT_ANY_HASH_TABLE_INC_VFP (this, ingress_chain, INGRESS_DEST_AND_Q, false, IOM_INFO::reallocate_dest_and_q_entry, NULL, ingress_pp_mask, false);
     INGRESS_NSAP_hash_table = CONSTRUCT_ANY_HASH_TABLE_INC_VFP (this, ingress_chain, INGRESS_NSAP, false, IOM_INFO::reallocate_nsap_entry, NULL, ingress_pp_mask, false);
     INGRESS_SUBSCRIBER_hash_table = CONSTRUCT_ANY_HASH_TABLE (this, ingress_chain, INGRESS_SUBSCRIBER, false, IOM_INFO::reallocate_ingress_sub_entry, NULL, ingress_pp_mask, false);
-    EGRESS_SUB_hash_table = CONSTRUCT_HASH_TABLE_COM (this, egress_chain, EGRESS_SUB, IOM_INFO::reallocate_egress_sub_entry, NULL, egress_pp_mask);
+    //EGRESS_SUB_hash_table = CONSTRUCT_HASH_TABLE_COM (this, egress_chain, EGRESS_SUB, IOM_INFO::reallocate_egress_sub_entry, NULL, egress_pp_mask);
+    EGRESS_SUB_hash_table = CONSTRUCT_HASH_TABLE_COM_INC_VFP (this, egress_chain, EGRESS_SUB, IOM_INFO::reallocate_egress_sub_entry, NULL, egress_pp_mask);
     INGRESS_IGMP_MULTICAST_hash_table = CONSTRUCT_HASH_TABLE (this, ingress_chain, INGRESS_IGMP_MULTICAST, IOM_INFO::reallocate_igmp_entry, NULL, ingress_pp_mask);
     INGRESS_BFD_SESSION_hash_table = CONSTRUCT_ANY_HASH_TABLE_INC_VFP (this, ingress_chain, INGRESS_BFD_SESSION, false, IOM_INFO::reallocate_bfd_entry, NULL, ingress_pp_mask, false);
     INGRESS_TLS_MIM_SVCID_hash_table = CONSTRUCT_HASH_TABLE (this, ingress_chain, INGRESS_TLS_MIM_SVCID, IOM_INFO::reallocate_mim_entry, NULL, ingress_pp_mask);
@@ -18146,7 +18147,7 @@ void IOM_INFO::queue_icc_response_async (IOM_ICC_ACTION action, tIccTransaction
 
     semTake(icc_async_resp_list_lock, WAIT_FOREVER);
     {
-        IOM_EVENT("Queueing ICC Async Response a=%u t=%p socket=%u qlen=%zu", action, t, t->Socket, icc_async_resp_list.size());
+//        IOM_EVENT("Queueing ICC Async Response a=%u t=%p socket=%u qlen=%zu", action, t, t->Socket, icc_async_resp_list.size());
         do_sem_give = icc_async_resp_list.empty();
         icc_async_resp_list.push_back(make_pair(action, t));
     }
diff --git a/iom/iom_main.h b/iom/iom_main.h
index 68fa47b..7e2bbcd 100644
--- a/iom/iom_main.h
+++ b/iom/iom_main.h
@@ -442,6 +442,7 @@ DECLARE_VFP_HASH_TABLE(INGRESS_BFD_SESSION)
 DECLARE_HASH_TABLE    (INGRESS_TLS_MIM_SVCID)
 DECLARE_HASH_TABLE    (INGRESS_MULTICAST)
 DECLARE_HASH_TABLE    (EGRESS_SUB)
+DECLARE_VFP_HASH_TABLE(EGRESS_SUB)
 DECLARE_P_HASH_TABLE  (QMDA_INGRESS_SUBSCRIBER)
 DECLARE_P_HASH_TABLE  (QMDA_INGRESS_NSAP)
 DECLARE_P_HASH_TABLE  (QMDA_INGRESS_TLS_MIM_SVCID)
diff --git a/iom/iom_msm_main.cpp b/iom/iom_msm_main.cpp
index ff2735b..9b63aa7 100644
--- a/iom/iom_msm_main.cpp
+++ b/iom/iom_msm_main.cpp
@@ -3669,7 +3669,7 @@ void IOM_MSM::send_msm_stats_req_msg(UINT32 tbl_idx)
 void IOM_MSM::calculate_rpt_stats_poll_time (UINT32 stats_active_count)
 {
     gRPT_STATS_POLL_TIME = 1 + (RPT_STATS_POLL_OPT_TIME/(iom_msm_num_sdfs/stats_active_count));
-    IOM_EVENT("gRPT_STATS_POLL_TIME %d stats_active_count %d RPT_STATS_POLL_OPT_TIME %d MAX_PER_MSM_SESSION_SDFS %d", gRPT_STATS_POLL_TIME, stats_active_count, RPT_STATS_POLL_OPT_TIME, iom_msm_num_sdfs);
+//    IOM_EVENT("gRPT_STATS_POLL_TIME %d stats_active_count %d RPT_STATS_POLL_OPT_TIME %d MAX_PER_MSM_SESSION_SDFS %d", gRPT_STATS_POLL_TIME, stats_active_count, RPT_STATS_POLL_OPT_TIME, iom_msm_num_sdfs);
     if ((MY_IOM->get_gw_type() == MSM_PGW_GGSN || MY_IOM->get_gw_type() == MSM_SCCG) && stats_active_count < RPT_STATS_ACTIVE_THRESHOLD_MAX)
     {
         /*
diff --git a/iom/iom_subscriber.cpp b/iom/iom_subscriber.cpp
index a4d8b2a..b628b78 100644
--- a/iom/iom_subscriber.cpp
+++ b/iom/iom_subscriber.cpp
@@ -46,17 +46,83 @@ static const char rcsid[] = "$Id$";
 #include "iom/iom_subscriber.h"
 #include "iom_api/iom_qos_common.h"
 #include "iom_api/iom_svc_types.h"
+#ifndef __mips__
+#include "pchip_code/vfp_hash.h"
+#endif
 
 DEFINE_HASH_TABLE            (INGRESS_SUBSCRIBER)
 DEFINE_P_ONLY_HASH_TABLE     (DPI_INGRESS_SUB_NEXTHOP)
 DEFINE_HASH_TABLE            (EGRESS_SUB)
+DEFINE_VFP_HASH_TABLE_FNS    (EGRESS_SUB)
 
 DEFINE_P_ONLY_HASH_TABLE     (INGRESS_SUB_NEXTHOP)
 DEFINE_NP_HASH_TABLE_FNS     (INGRESS_NP_SUB_NEXTHOP)
+DEFINE_VFP_HASH_TABLE_FNS    (INGRESS_NP_SUB_NEXTHOP)
 
 DEFINE_HASH_CONVERT_KEY1     (np_hash_, INGRESS_NP_SUB_NEXTHOP, INGRESS_NP_SUB_NEXTHOP_LOOKUP_KEY)
 DEFINE_HASH_CONVERT_KEY2     (np_hash_, INGRESS_NP_SUB_NEXTHOP, INGRESS_SUB_NEXTHOP_LOOKUP_KEY)
 
+
+UINT32 vfp_hash_INGRESS_NP_SUB_NEXTHOP_TABLE::get_signature(void * key)
+{
+    UINT32 sig = 0;
+#ifndef __mips__
+    INGRESS_NP_SUB_NEXTHOP_LOOKUP_KEY * key_in = (INGRESS_NP_SUB_NEXTHOP_LOOKUP_KEY *)key;
+
+    if (key_in->is_alt_type)
+    {
+        if (key_in->alt_type == NP_SUB_NEXTHOP_ALT_TYPE_RDI)
+        {
+            sig = vfp_hash_1word(key_in->rdi);
+        }
+    }
+    else
+    {
+        if (key_in->type == NP_SUB_NEXTHOP_TYPE_NONE)
+        {
+            sig = vfp_hash_2words(key_in->routed.vrf, *(UINT32 *) &key_in->routed.ip);
+        }
+        else if (key_in->type == NP_SUB_NEXTHOP_TYPE_L2TP)
+        {
+            sig = vfp_hash_2words(key_in->l2tp.tunnel_id, key_in->l2tp.session_id);
+        }
+        else if (key_in->type == NP_SUB_NEXTHOP_TYPE_GTP)
+        {
+            // not supported yet
+        }
+    }
+#endif
+    return sig;
+}
+
+UINT32 vfp_hash_EGRESS_SUB_TABLE::get_signature(void * key)
+{
+    UINT32 sig = 0;
+#ifndef __mips__
+    EGRESS_SUB_LOOKUP_KEY * key_in = (EGRESS_SUB_LOOKUP_KEY *)key;
+
+    if (key_in->is_non_sub_context_lookup)
+    {
+        sig = vfp_hash_2words(key_in->n.key.sdp.sdp_binding_idx, key_in->n.key.sdp.out_port_num);
+    }
+    else if (key_in->s.is_l2tp)
+    {
+        sig = vfp_hash_2words(key_in->s.global_sap_index, *((UINT32 *)&key_in->s.l2tp));
+    }
+    else
+    {
+        sig = vfp_hash_2words(key_in->s.global_sap_index, *((UINT32 *)&key_in->s.dest_ip));
+
+        if (key_in->s.is_ipv6)
+        {
+            sig ^= vfp_hash_1word(*(UINT32 *)&key_in->s.dest_ipv6.b[4]); // bytes 0-3 went in dest_ip.
+        }
+    }
+#endif
+    return sig;
+}
+
+
 /*=========================================================================================*/
 
 #define SUBSCRIBER_IOM_LOCK_BOUNCE_TICKS               (TIMOS_TICKS_PER_SEC / 10)
@@ -11265,10 +11331,18 @@ IOM_SUBSCRIBER::IOM_SUBSCRIBER (PP_PROG_MASK ingress_init_pp_mask, PP_PROG_MASK
       subscriber_incipient_group_allocator(),
       subscriber_ip_nexthop_allocator (),
       sub_host_v6_prefix_group_allocator (),
+      /*
       INGRESS_SUB_NEXTHOP_hash_table (iom_has_npchips ? CONSTRUCT_NP_HASH_TABLE (NULL, CHAIN_MASK_FLAG, INGRESS_NP_SUB_NEXTHOP, false, 
                                                                                  IOM_INFO::reallocate_sub_host_entry, NULL,ingress_init_pp_mask, false)
                                                       : CONSTRUCT_P_HASH_TABLE (NULL, CHAIN_MASK_FLAG, INGRESS_SUB_NEXTHOP, false, 
                                                                                 IOM_INFO::reallocate_sub_host_entry, ingress_init_pp_mask)),
+      */
+      INGRESS_SUB_NEXTHOP_hash_table (iom_has_vfp ? CONSTRUCT_VFP_HASH_TABLE (NULL, CHAIN_MASK_FLAG, INGRESS_NP_SUB_NEXTHOP, false,
+                                                                              IOM_INFO::reallocate_sub_host_entry, ingress_init_pp_mask)
+                                                  : iom_has_npchips ? CONSTRUCT_NP_HASH_TABLE (NULL, CHAIN_MASK_FLAG, INGRESS_NP_SUB_NEXTHOP, false, 
+                                                                                 IOM_INFO::reallocate_sub_host_entry, NULL,ingress_init_pp_mask, false)
+                                                                    : CONSTRUCT_P_HASH_TABLE (NULL, CHAIN_MASK_FLAG, INGRESS_SUB_NEXTHOP, false, 
+                                                                                IOM_INFO::reallocate_sub_host_entry, ingress_init_pp_mask)),
       DPI_INGRESS_SUB_NEXTHOP_hash_table (NULL),
       low_prio_sub_work_queue ("-SubsLoWQ-", WORK_QUEUE_PRIORITY_LOW, (iom_max_subscriber_hosts_per_esr + NUM_SUBSCRIBER_L2_HOSTS_PER_ESR + NUM_SUBSCRIBER_APPS_PER_IOM)),
       low_prio_sub_lag_work_queue ("-SubsLagLoWQ-", WORK_QUEUE_PRIORITY_LOW, NUM_SUBSCRIBER_APPS_PER_IOM),
diff --git a/pchip_code/egress_frame.inc b/pchip_code/egress_frame.inc
index 4429bdf..d948d38 100644
--- a/pchip_code/egress_frame.inc
+++ b/pchip_code/egress_frame.inc
@@ -644,6 +644,7 @@ typedef struct
 } IPV4_SVC_HDR;                                   //  20 + 4 = 24 bytes
 
 // The L3/L4 network service header which goes on a PPPOE frame on its way to an L2TP LAC
+.export_macros_start
 export typedef struct
 {
     struct
@@ -654,6 +655,7 @@ export typedef struct
     L2TP_HEADER             l2tp;
     POS_ADDR_AND_CTRL       addr_and_ctrl;
 } IPV4_L2TP_HDR;                                // 20 + 8 + 6 + 2 = 36 bytes
+.export_macros_end
 
 export typedef struct
 {
diff --git a/pchip_code/np_ingress_c.cpp b/pchip_code/np_ingress_c.cpp
index c90c5d7..f14df19 100644
--- a/pchip_code/np_ingress_c.cpp
+++ b/pchip_code/np_ingress_c.cpp
@@ -3316,6 +3316,7 @@ l2tp_packet:
 #endif
     if (psi.is_ipv6) goto done_ip_filter;
     if (psi.is_mac_in_mac) goto done_ip_filter;
+    pchip_log_criteria("l2tp=1");
     pchip_logpf("Provisional to CPM reason code L2TP\n");
     SET_TO_CPM_CODE_PROVISIONAL(psi, TO_CPM_RAW_REASON_L2TP_CONTROL)
     goto done_ip_filter;
@@ -13494,7 +13495,7 @@ route_to_local_subnet:
         if (if_dest_info.dhcp_snooping_enabled) LOG();
         p1_flags.dhcp_snooping_enabled = if_dest_info.dhcp_snooping_enabled;
         }
-    if (PCHIP_IS_EQU(local_subnet_record.subnet_ip_addr, nexthop_ip_and_l2tp.ip)) { YLOG(non_svc_bits2.is_bfd); YLOG(psi.cpm_reason.code == TO_CPM_RAW_REASON_L2TP_CONTROL); goto send_routed_frame_to_cpm_check_l2tp; }
+    if (PCHIP_IS_EQU(local_subnet_record.subnet_ip_addr, nexthop_ip_and_l2tp.ip)) { YLOG(non_svc_bits2.is_bfd); YLOG(psi.cpm_reason.code == TO_CPM_RAW_REASON_L2TP_CONTROL); pchip_logpf("Possible l2tp\n"); goto send_routed_frame_to_cpm_check_l2tp; }
 
     if (if_dest_info.is_loopback)  goto host_unreachable_routing_check_dhcp_snooping;
     for (unsigned i=0; i<MAX_VRRP_ADDRESSES_PER_INTERFACE; i++)
@@ -13539,7 +13540,7 @@ send_routed_frame_to_cpm_check_l2tp:
     if (l2tp_lns_hdr.flags_and_vers.control)
         {
         LOG();
-        pchip_logpf("l2tp control - to be forwarded to CPM\n");
+        pchip_logpf("l2tp control - to be forwarded to CPM & psi.msm_reason_code: %d\n", psi.msm_reason_code);
         goto send_routed_frame_to_cpm;
         }
     if (psi.ip_routing.l2tp_hdrs_length == 0) goto discard_frame_invalid_l2tp_header;
@@ -13907,6 +13908,7 @@ l2tp_ppp_lcp_echo_req_reply:
 
 l2tp_ppp_data_to_msm:
     /*LOG(); TB TODO*/
+    pchip_log_criteria("l2tp-mg-data=1"); 
     pchip_logpf("L2TP PPP Data frame Chunk id %u\n", sub_nexthop_record.msm_chunk_id);
     psi.msm.chunk_id = sub_nexthop_record.msm_chunk_id;
     psi.msm_reason_code = TO_MSM_REASON_L2TP_OR_EXT;
diff --git a/pchip_code/np_msm_ingress_c.cpp b/pchip_code/np_msm_ingress_c.cpp
index 6dff29d..5642563 100644
--- a/pchip_code/np_msm_ingress_c.cpp
+++ b/pchip_code/np_msm_ingress_c.cpp
@@ -13019,7 +13019,10 @@ dont_forward_check_routed_v6:
 #if INGRESS_MSM_FWD_SUPPORT
     // psi.msm_l2tp_ip_not_ppp maybe set because of msm_v6_pbr_nexthop. check for is_v6 
     if (psi.msm_l2tp_ip_not_ppp && (psi.is_ipv6 == 0)) 
+    {
         svc_bits.is_sap_to_l2tp = 1;
+        pchip_logpf("msm_l2tp_ip_not_ppp, & p1_flags.strip_l2_hdr.l2tp_ip_not_ppp: %d\n", p1_flags.strip_l2_hdr.l2tp_ip_not_ppp);
+    }
 
     if ((psi.msm_vars) && (psi.msm_dpi.null_frame))
     {
@@ -18812,6 +18815,7 @@ done_dpi_network_l2tp:
 
         PCHIP_MEMSET(OUT_FRAME2_EXTRA_HDR_PTR + (sw_hdr.common.has_dpi_extra ? SW_FAB_HDR_DPI_EXTRA__BYTES : 0), 0, SW_FAB_HDR_L2TP_EXTRA__BYTES);
 
+        pchip_logpf("payload_length: %d, output_frame_offset: %d, p1_flags.strip_l2_hdr.l2_hdr_size: %d\n", payload_length, output_frame_offset, p1_flags.strip_l2_hdr.l2_hdr_size);
         output_frame_offset += p1_flags.strip_l2_hdr.l2_hdr_size;
         payload_length -= p1_flags.strip_l2_hdr.l2_hdr_size;
 
diff --git a/pchip_code/vfp_egress_c.cpp b/pchip_code/vfp_egress_c.cpp
index b6a6956..879d083 100755
--- a/pchip_code/vfp_egress_c.cpp
+++ b/pchip_code/vfp_egress_c.cpp
@@ -3079,6 +3079,97 @@ vfp_egr_gre_tunnel_encap(tVfpPacketDesc         *pDesc,
     return (true); 
 }
 
+/**************************************************************************************************
+ * l2tp tunnel
+ *************************************************************************************************/
+VFP_INLINE void VFP_FUNCTION_TAG VFP_FN_HOT
+vfp_egr_build_ipv4_l2tp(UINT8                           *frame_out,
+                        INT32                           *out_ptr,
+                        UINT32                           frame_length,
+                        const L2TP_BINDING_AND_SESSION  *l2tp_binding,
+                        UINT8                            l2tp_dscp)
+{
+    EGRESS_L2TP_CONFIG *l2tp_config = &EGRESS_L2TP_CFG_TABLE_CTABLE[l2tp_binding->binding_index];
+    pchip_logpf("Read EGRESS_L2TP_CFG_TABLE - l2tp_tunnel=%u dest_port=%u dont_fragment=%u\n",
+        l2tp_config->tunnel_id, l2tp_config->dest_port, l2tp_config->dont_fragment);
+
+    if (l2tp_binding->ip_not_ppp)
+    {
+        *out_ptr -= NAT_IPV4_L2TP_HDR__BYTES;
+        *(UINT16 *)&frame_out[*out_ptr + IPV4_L2TP_HDR__BYTES] = rte_constant_bswap16(PPP_PROTOCOL_IPV4);
+    }
+    else
+    {
+        *out_ptr -= IPV4_L2TP_HDR__BYTES;
+    }
+
+    pchip_logpf("Building IPv4_L2TP header ");
+
+#define l2tp_raw_ptr &frame_out[*out_ptr]
+
+    // addr_and_ctrl
+    UINT16 *pos = (UINT16 *)fetch_IPV4_L2TP_HDR__addr_and_ctrl_ptr(l2tp_raw_ptr);
+    *pos = ((POS_ADDR_VAL << 0) | (POS_CTRL_VAL << 8));
+
+    pchip_logpf("[addr=%u ctrl=%u] ",
+        fetch_IPV4_L2TP_HDR__addr_and_ctrl_addr(l2tp_raw_ptr),
+        fetch_IPV4_L2TP_HDR__addr_and_ctrl_ctrl(l2tp_raw_ptr)
+        );
+
+    // l2tp
+    UINT8 *l2tp = (UINT8 *)fetch_IPV4_L2TP_HDR__l2tp_ptr(l2tp_raw_ptr);
+    put_L2TP_HEADER__flags_and_vers(l2tp, L2TP_VERSION);
+    put_L2TP_HEADER__ids_tunnel_id (l2tp, l2tp_config->tunnel_id);
+    put_L2TP_HEADER__ids_session_id(l2tp, l2tp_binding->session_id);
+
+    pchip_logpf("l2tp [version=%u tunnel_id=%u session_id=%u] ",
+        fetch_IPV4_L2TP_HDR__l2tp_flags_and_vers_version(l2tp_raw_ptr),
+        fetch_IPV4_L2TP_HDR__l2tp_ids_tunnel_id (l2tp_raw_ptr),
+        fetch_IPV4_L2TP_HDR__l2tp_ids_session_id(l2tp_raw_ptr)
+        );
+
+    // udp
+    UINT8 *udp = (UINT8 *)fetch_IPV4_L2TP_HDR__ipv4_udp_udp_ptr(l2tp_raw_ptr);
+    put_UDP_HEADER__ports_source(udp, UDP_PORT_L2TP);
+    put_UDP_HEADER__ports_dest  (udp, l2tp_config->dest_port);
+    if (l2tp_binding->ip_not_ppp)
+        put_UDP_HEADER__length(udp, frame_length + UDP_HEADER__BYTES + L2TP_HEADER__BYTES + POS_ADDR_AND_CTRL__BYTES + POS_HEADER__BYTES);
+    else
+        put_UDP_HEADER__length(udp, frame_length + UDP_HEADER__BYTES + L2TP_HEADER__BYTES + POS_ADDR_AND_CTRL__BYTES);
+    put_UDP_HEADER__checksum(udp, 0);
+
+    pchip_logpf("udp [src=%u dst=%u len=%u] ",
+        fetch_IPV4_L2TP_HDR__ipv4_udp_udp_ports_source(l2tp_raw_ptr),
+        fetch_IPV4_L2TP_HDR__ipv4_udp_udp_ports_dest(l2tp_raw_ptr),
+        fetch_IPV4_L2TP_HDR__ipv4_udp_udp_length(l2tp_raw_ptr)
+        );
+
+    // ip
+    UINT8 *ip4 = (UINT8 *)fetch_IPV4_L2TP_HDR__ipv4_udp_ipv4_ptr(l2tp_raw_ptr);
+    put_IPV4_HEADER__version_ihl  (ip4, DEFAULT_IPV4_VERSION_IHL);
+    put_IPV4_HEADER__dscp_dscp_val(ip4, l2tp_dscp);
+    put_IPV4_HEADER__total_length (ip4, frame_length + (l2tp_binding->ip_not_ppp ? NAT_IPV4_L2TP_HDR__BYTES : IPV4_L2TP_HDR__BYTES));
+    put_IPV4_HEADER__frag_offset_and_flags(ip4, (l2tp_config->dont_fragment ? 0x4000 : 0x0000));
+    put_IPV4_HEADER__ttl(ip4, INITIAL_TTL);
+    put_IPV4_HEADER__protocol(ip4, IP_PROTOCOL_UDP);
+    put_IPV4_HEADER__checksum(ip4, 0);
+
+    put_IPV4_HEADER__addresses_sa(ip4, rte_bswap32(*(UINT32 *)&l2tp_config->tunnel_addresses.sa));
+    put_IPV4_HEADER__addresses_da(ip4, rte_bswap32(*(UINT32 *)&l2tp_config->tunnel_addresses.da));
+
+    pchip_logpf("ipv4 [vihl=0x%x dscp=0x%x ttl=%u len=%u sa=0x%08x da=0x%08x]\n",
+        fetch_IPV4_L2TP_HDR__ipv4_udp_ipv4_version_ihl(l2tp_raw_ptr),
+        fetch_IPV4_L2TP_HDR__ipv4_udp_ipv4_dscp_dscp_val(l2tp_raw_ptr),
+        fetch_IPV4_L2TP_HDR__ipv4_udp_ipv4_ttl(l2tp_raw_ptr),
+        fetch_IPV4_L2TP_HDR__ipv4_udp_ipv4_total_length(l2tp_raw_ptr),
+        fetch_IPV4_L2TP_HDR__ipv4_udp_ipv4_addresses_sa(l2tp_raw_ptr),
+        fetch_IPV4_L2TP_HDR__ipv4_udp_ipv4_addresses_da(l2tp_raw_ptr)
+        );
+
+#undef l2tp_raw_ptr
+}
+
+
 #define SVC_PARMS       sw_fab_hdr->parm.svc
 #define CORE_PARMS      sw_fab_hdr->parm.core
 
@@ -5148,6 +5239,7 @@ vfp_egr_core_handler(tVfpPacketDesc *pDesc, SW_FABRIC_HEADER *sw_fab_hdr)
     bool                            sap_qos_filter_override = FALSE; 
     bool                            clear_df_for_frag = FALSE;
     bool                            drop_pref_queue = FALSE;
+    UINT8                           l2tp_outer_dscp = 0;
 
     // Define variable to store jump labels.
     jump_var(jump_addr);
@@ -5166,7 +5258,14 @@ vfp_egr_core_handler(tVfpPacketDesc *pDesc, SW_FABRIC_HEADER *sw_fab_hdr)
         frame_out    += sizeof(SW_FAB_HDR_IPV6_EXTRA);
         frame_length -= sizeof(SW_FAB_HDR_IPV6_EXTRA); 
     }
-    
+    else if (unlikely(sw_fab_hdr->common.has_l2tp_extra))
+    {
+//        frame_out    += sizeof(SW_FAB_HDR_L2TP_EXTRA);
+//        frame_length -= sizeof(SW_FAB_HDR_L2TP_EXTRA);
+        frame_out    += SW_FAB_HDR_L2TP_EXTRA__BYTES;
+        frame_length -= SW_FAB_HDR_L2TP_EXTRA__BYTES;
+    }
+   
     out_ptr         = - IPV4_HEADER__BYTES;
     drop_pref_queue = !!(sw_fab_hdr->common.qos.in_profile & 0x01);
     fc              = sw_fab_hdr->common.qos.fc;
@@ -5523,6 +5622,8 @@ jump_label(sap_filter)
                     tos = (tos & 0x1f) | ((sap_fc_dscp_marking->value.dscp << 2) & 0xe0);
                 
                 XLOG(sap_fc_dscp_marking->prec_bits_only);
+
+                l2tp_outer_dscp = sap_fc_dscp_marking->value.dscp;
             }
 
 #if 0 //Causing crash - TODO investigate
@@ -5568,6 +5669,8 @@ nw_qos_marking:
                 tos = (tos & 3) | (qos_entry->dscp << 2);
                 CORE_PARMS.cp3.bits.exp = qos_entry->exp;
             }
+
+            l2tp_outer_dscp = qos_entry->dscp;
             
             // We already decided to egress via network i/f. So avoiding another conditional jump
             // on same while adding egress tags.
@@ -5575,7 +5678,38 @@ nw_qos_marking:
         }
     }
 
-    if (CORE_PARMS_1.flags.ip_not_mpls)
+    if (unlikely((sw_fab_hdr->common.has_l2tp_extra)))
+    {
+        //PCHIP_ASSERT((UINT8 *)sw_fab_hdr != buf);       // we expect the fabric header is cached
+
+        SW_FAB_HDR_L2TP_EXTRA    *l2tp_extra_ptr = (SW_FAB_HDR_L2TP_EXTRA *)(sw_fab_hdr +1);
+        L2TP_BINDING_AND_SESSION *l2tp_info_ptr  = &l2tp_extra_ptr->binding_and_session;
+        UINT8 *l2tp_data = (UINT8 *)(sw_fab_hdr +1);
+        SW_FAB_HDR_L2TP_EXTRA l2tp_extra;
+        L2TP_BINDING_AND_SESSION l2tp_info;
+
+        convert_to_SW_FAB_HDR_L2TP_EXTRA(&l2tp_extra, l2tp_data);
+        l2tp_info  = l2tp_extra.binding_and_session;
+
+        pchip_logpf("Read L2TP extra [binding-index=%u:0x%x ip_not_ppp=%u is_gtp=%u] [session=%u:0x%x]\n",
+            l2tp_info_ptr->binding_index, l2tp_info_ptr->binding_index, l2tp_info_ptr->ip_not_ppp, l2tp_info_ptr->is_gtp, l2tp_info_ptr->session_id, l2tp_info_ptr->session_id);
+
+        pchip_logpf("Read L2TP extra [binding-index=%u:0x%x ip_not_ppp=%u is_gtp=%u] [session=%u:0x%x]\n",
+            l2tp_info.binding_index, l2tp_info.binding_index, l2tp_info.ip_not_ppp, l2tp_info.is_gtp, l2tp_info.session_id, l2tp_info.session_id);
+
+        //vfp_egr_build_ipv4_l2tp(frame_out, &out_ptr, frame_length + IPV4_HEADER__BYTES, l2tp_info, l2tp_outer_dscp);
+        vfp_egr_build_ipv4_l2tp(frame_out, &out_ptr, frame_length + IPV4_HEADER__BYTES, &l2tp_info, l2tp_outer_dscp);
+
+        ip_ptr = &frame_out[out_ptr];
+        if (unlikely(rte_memiszero(fetch_IPV4_HEADER__addresses_da_ptr(ip_ptr), sizeof(IP_ADDRESS))))
+        {
+            return (vfp_egr_discard(pDesc, EGRESS_STAT_NULL_DEST_IP));
+        }
+
+        UINT16 checksum = vfp_egr_ipv4_hdr_checksum_calc(ip_ptr);
+        put_IPV4_HEADER__checksum(ip_ptr, checksum);
+    }
+    else if (CORE_PARMS_1.flags.ip_not_mpls)
     {
         /**************************************************************************************************
         * update ip hdr/check for frag
diff --git a/pchip_code/vfp_ingress_c.cpp b/pchip_code/vfp_ingress_c.cpp
index 08e124c..d4fe3e6 100755
--- a/pchip_code/vfp_ingress_c.cpp
+++ b/pchip_code/vfp_ingress_c.cpp
@@ -239,7 +239,17 @@ typedef struct t_vfp_msm_reason
         IP_ADDRESS                  ipv4_da_for_routing_lookup;      //32
         IPV6_ADDRESS                ipv6_da_for_routing_lookup;
     } ip_routing;
-
+    struct
+    {
+        L2TP_OR_GTP_SESSION_AND_GLOBAL_SUB_ID   l2tp_or_gtp_session;
+        bool                                    msm_l2tp_ip_not_ppp;
+    };
+    struct
+    {
+        bool                        is_sap_to_l2tp;
+    }svc_bits;
+    INGRESS_L2_HEADER_SIZE          l2_hdr_size;
+ 
 } t_vfp_msm_reason;  // unpacked version of psi.msm
 
 /**************************************************************************************************
@@ -434,6 +444,12 @@ typedef struct t_ing_zeroed {
     BOOLEAN             source_is_spoke;                    //  + 1 = 23
     BOOLEAN             drop_frame_if_route_da_mcast;       //  + 1 = 24
     LOCAL_SUB_APP_INDEX subscriber_app_index;               // KWH TODO - temp, move out!
+    struct
+    {
+        UINT8                       l2tp_tunnel_id_msb;
+        UINT8                       l2tp_tunnel_id_lsb;
+        F_UINT(7,                   l2tp_hdrs_length);
+    } ip_routing;
 } t_ing_zeroed;
 
 #ifdef GCC_ABI_64
@@ -983,6 +999,7 @@ vfp_ing_l4hdr_classify(UINT8 *ip_ptr, t_ing_unpacked_ipv4 *unpacked_ip, t_vfp_cp
                 case UDP_PORT_L2TP:
                     if (!is_ipv6)
                         SET_TO_CPM_CODE_PROVISIONAL(cpm_reason, TO_CPM_RAW_REASON_L2TP_CONTROL);
+                    pchip_log_criteria("l2tp=1");
                     break;
                 case UDP_PORT_BOOTPC:
                 case UDP_PORT_BOOTPS:
@@ -2165,6 +2182,10 @@ vfp_ing_forward_to_msm(tVfpPacketDesc *pDesc, tVfpWorkerHandlerData *worker_info
 //        sw_hdr->parm.raw.main.to_msm.tunnel_id &= ~(((1 << MSM_CHUNK_TASK_ID__BITS) - 1) << MSM_SESSION_BEARER_ID__BITS);
         pchip_logpf("Chunk %d Micronet %d Offset %d ", msm->chunk_id, sw_hdr->parm.raw.main.to_msm.micronet_id, sw_hdr->parm.raw.main.to_msm.sess_ip_offset);  
     
+        if (MSM_REASON_CODE(msm) == TO_MSM_REASON_L2TP_OR_EXT)
+        {
+            sw_hdr->common.qos.in_profile = ing_qos->in_profile;
+        }
         // UE to UE case
         if (msm && msm->msm_stats)
         {
@@ -2748,6 +2769,8 @@ vfp_ing_routing_dest_lookup(tVfpPacketDesc *pDesc, tVfpWorkerHandlerData *worker
     const INGRESS_IPV6_LOCAL_SUBNET_RECORD2 *local_v6_subnet_record2        VFP_TABLE_PTR_INIT;
     const INGRESS_IPV6_SUBNET_INTF_ADDRS    *ipv6_local_subnet_addresses    VFP_TABLE_PTR_INIT;
     const INTERFACE_DEST_DPI_INFO           *if_dest_dpi_info               VFP_TABLE_PTR_INIT;
+    const INGRESS_NP_SUB_NEXTHOP_RECORD     *sub_nexthop_record             VFP_TABLE_PTR_INIT;
+    const INGRESS_NP_SUB_NEXTHOP_RECORD2    *sub_nexthop_data               VFP_TABLE_PTR_INIT;
 
     IOM_IP_INTERFACE_INDEX                  dest_if_index;
     IP_PREFIX_LEN                           subnet_prefix_len;
@@ -3136,7 +3159,7 @@ common_mpls_tunnel_ip_nh:
     if (fwd_path == VFP_FWD_PATH_MPLS)
         return true;//goto handle_dest_and_q_ucast;
     subnet_prefix_len = ip_nexthop_info->subnet_prefix_len;
-    goto common_routing_finish;
+    goto done_routing_check_gtp_encap;
 
 
     /**************************************************************************************************
@@ -3165,7 +3188,8 @@ route_to_local_subnet:
     *if_dest_info = &INGRESS_INTERFACE_DEST_INFO_TABLE_CTABLE[dest_if_index];
     if (unlikely(rte_memequal(&local_subnet_record->subnet_ip_addr, &nexthop_ip_and_l2tp->ip, 4)))
     {
-        goto send_routed_frame_to_cpm_check_gtp;
+        //pchip_log_criteria("l2tp=1");
+        goto send_routed_frame_to_cpm_check_l2tp;
     }
     if (unlikely((*if_dest_info)->is_loopback))
         goto host_unreachable_routing;
@@ -3299,6 +3323,22 @@ route_to_internal_nexthop:
     * common routing
     ***************************************************************************************************/
 
+done_routing_check_gtp_encap:
+    XLOG(msm->svc_bits.is_sap_to_l2tp);
+    if (msm->svc_bits.is_sap_to_l2tp)
+    {
+        //msm->service_type = SERVICE_TYPE_L2TP; // access side l2tp (pppoe->l2tp)
+#if 0
+        XLOG(psi.l2tp_or_gtp_session.is_gtp);
+        if (psi.l2tp_or_gtp_session.is_gtp)
+        {
+            read_INGRESS_GTP_ENCAP_RECORD_TABLE(chain, &gtp_encap_info, psi.l2tp_or_gtp_session.session_id);
+            pchip_logpf("GTP: sub_idx=%d te_id=0x%08x src_port=0x%04x\n", psi.l2tp_or_gtp_session.session_id, gtp_encap_info.te_id, gtp_encap_info.udp_src_port);
+            PCHIP_ZERO(psi.l2tp_or_gtp_session.session_id);
+        }
+#endif
+    }
+
 common_routing_finish:
 
     // eventually should just move these bits to if_dest_info, then skip this table read if not set
@@ -3452,12 +3492,271 @@ discard_to_sdp_frame_invalid:
     ing->discard_stat_num = INGRESS_STAT_SDP_TO_ROUTING_FAILED;
     goto dont_forward_just_copy;
 
+discard_frame_invalid_l2tp_header:
+    pchip_logpf("discard frame invalid L2TP header\n");
+    ing->discard_stat_num = INGRESS_STAT_L2TP_OR_PPPOE_FRAME_INVALID;
+    goto dont_forward_just_copy;
+
 dont_forward_just_copy:
     // in the future we may need to copy this frame but for now we only discard
     return vfp_ing_discard(pDesc, ing->discard_stat_num, port_record);
 
 
     /**************************************************************************************************
+    * network side l2tp sub-lookup
+    ***************************************************************************************************/
+
+send_routed_frame_to_cpm_check_l2tp:
+
+    // can only get here if fwd_path == VFP_FWD_PATH_IP_ROUTING, otherwise special_ucast_l3 == NULL
+    if (ing->cpm_reason.code != TO_CPM_RAW_REASON_L2TP_CONTROL) goto send_routed_frame_to_cpm_check_gtp;
+
+
+    {
+        UINT8 *l2tp_hdr = ing->ip_ptr + IPV4_HEADER__BYTES + UDP_HEADER__BYTES;
+        UINT8 *post_l2tp_hdr = l2tp_hdr;
+        L2TP_TUNNEL_AND_SESSION l2tp_ids;
+        UINT8 *mpls_or_ipv4 = ing->ip_ptr;
+
+        // The v4 frame should already be sent to the CPM if options are present.
+        if (fetch_L2TP_HEADER__flags_and_vers_control(l2tp_hdr))
+        {
+            LOG();
+            pchip_logpf("l2tp control - to be forwarded to CPM\n");
+            goto send_routed_frame_to_cpm;
+        }
+
+        if (fetch_L2TP_HEADER__flags_and_vers_version(l2tp_hdr) != L2TP_VERSION)
+        {
+            LOG();
+            goto discard_frame_invalid_l2tp_header;
+        }
+
+        // Length validation - the normal routing code ensures the frame is large enough given the length in the ip hdr.
+        // This code ensures the IP+UDP+L2TP+PosAC hdrs < length in ip hdr, and IP+UDP+L2TP+PosAC hdrs < 128 (the max we strip).
+        // Note, no validation done of L2TP length, it is ignored (though L2TP hdr will still be parsed correctly if present)
+
+        if (fetch_L2TP_HEADER__flags_and_vers_length_present(l2tp_hdr))
+        {
+            LOG();
+            post_l2tp_hdr += 2; // +2=size of length field
+        }
+
+        l2tp_ids.tunnel_id = fetch_L2TP_HEADER__ids_tunnel_id(post_l2tp_hdr);
+        l2tp_ids.session_id = fetch_L2TP_HEADER__ids_session_id(post_l2tp_hdr);
+
+        if (fetch_L2TP_HEADER__flags_and_vers_sequence_present(l2tp_hdr))
+        {
+            // Skip over the sequence numbers, we don't look at them if they are present
+            LOG();
+            post_l2tp_hdr += 4; // +4=size of sequence field
+        }
+        if (fetch_L2TP_HEADER__flags_and_vers_offset_present(l2tp_hdr))
+        {
+            UINT32 l2tp_hdr_and_off;
+            LOG();
+
+            l2tp_hdr_and_off = fetch_L2TP_HEADER_AND_OFFSET__offset_length(post_l2tp_hdr);
+
+            pchip_logpf("Adding l2tp offset %u\n", l2tp_hdr_and_off);
+            post_l2tp_hdr += l2tp_hdr_and_off + 2;  // +2 = offset_length size
+        }
+
+        post_l2tp_hdr += L2TP_HEADER__BYTES + POS_ADDR_AND_CTRL__BYTES;
+
+        UINT32 l2tp_hdrs_length = (UINT32) (post_l2tp_hdr - ing->ip_ptr);
+
+        // KWH TODO - have full length in unpacked hdr..
+        if (fetch_IPV4_HEADER__total_length(ing->ip_ptr) <= l2tp_hdrs_length)
+        {
+            LOG();
+            pchip_logpf("L2TP: invalid ip hdr len %u l2tp hdrs %u\n", fetch_IPV4_HEADER__total_length(ing->ip_ptr), l2tp_hdrs_length);
+            goto discard_frame_invalid_l2tp_header;
+        }
+        //    if (l2tp_hdrs_length >= 128) goto done_l2tp_check; // only support 7 bits of hdr to strip - doesn't matter on vfp
+
+        pchip_logpf("Doing l2tp subscriber lookup tunnel 0x%x session 0x%x psi.incoming_ttl %u\n",
+                l2tp_ids.tunnel_id, l2tp_ids.session_id, incoming_ttl);
+
+        //XLOG(incoming_ttl <= 1); // don't do TTL expiry if terminating tunnel
+
+        // don't send dest unreachables, as the destination is reachable just the tunnel/session might not be
+        ing->no_icmp = 1;
+
+        UINT32                                  sig, sub_rec_index;
+        sig = vfp_hash_2words(l2tp_ids.tunnel_id, l2tp_ids.session_id);
+        sig = sig % VFP_INGRESS_NP_SUB_NEXTHOP_INITIAL_VFP_HASH_TABLE__ENTRIES;
+        sub_rec_index = INGRESS_NP_SUB_NEXTHOP_INITIAL_VFP_HASH_TABLE_CTABLE[sig];
+        pchip_logpf("initial idx=%u sub_rec_index=%u\n", sig, sub_rec_index);
+        while (1)
+        {
+            sub_nexthop_record = &INGRESS_NP_SUB_NEXTHOP_RECORD_TABLE_CTABLE[sub_rec_index];
+            //sub_nexthop_data = &INGRESS_NP_SUB_NEXTHOP_RECORD2_TABLE_CTABLE[sub_rec_index];
+            sub_nexthop_data = &INGRESS_NP_SUB_NEXTHOP_RECORD2_TABLE_copy_0_CTABLE[sub_rec_index];
+            if (likely((sub_nexthop_data->key.l2tp.tunnel_id == l2tp_ids.tunnel_id) &&
+                        (sub_nexthop_data->key.l2tp.session_id == l2tp_ids.session_id) &&
+                        (sub_nexthop_data->key.is_alt_type == 0) &&
+                        (sub_nexthop_data->key.type == NP_SUB_NEXTHOP_TYPE_L2TP)))
+                break;
+
+            sub_rec_index = sub_nexthop_record->next;
+            if (unlikely(sub_rec_index == 0))
+            {
+                pchip_logpf("sub_rec_index is 0\n");
+                goto sub_nh_not_found;
+            }
+        }
+
+        if (sub_nexthop_record->dest_sap_index == 0)
+        {
+            LOG();
+            pchip_logpf("sub_nexthop_record->dest_sap_index is 0\n");
+            goto sub_nh_unreachable;
+        }
+
+        LOG();
+        pchip_logpf("Got sub index %u global_sub_index %u dest_sap_index %u spoke-if-index %u dest VRF ID %d is_lac %u\n",
+                0/*sub_nh_index*/, sub_nexthop_record->global_sub_index, sub_nexthop_record->dest_sap_index,
+                sub_nexthop_record->redirect_to_if ? sub_nexthop_record->red_data.redirect_if_index : 0, sub_nexthop_data->sub_vrf_id,
+                sub_nexthop_record->is_lac);
+
+        // swap to l2tp service type
+        svc_tx_info->ids = l2tp_ids;
+        p1_flags->is_svc_frame = 1;
+
+        svc_tx_info->endpoint.is_sap = 1;
+        svc_tx_info->endpoint.sap_idx = sub_nexthop_record->dest_sap_index;
+        svc_tx_info->strip_l2_hdr_size = (UINT16) (post_l2tp_hdr - VFP_PACKET_DESC_GET_DPTR(pDesc));
+
+        //      psi.service_type = SERVICE_TYPE_L2TP;
+        //        PCHIP_ZERO(psi.svc);
+        //        svc_bits.evpn_type = EVPN_TYPE_NONE;
+        //        p1_flags.strip_l2_hdr.l2tp_ip_not_ppp = sub_nexthop_record->sub_host.is_l2tp_to_ipoe_or_gtp;
+        //        psi.dscp_marking.in.value.dscp = l2tp_dscp;
+        //        XLOG(p1_flags.strip_l2_hdr.l2tp_ip_not_ppp);
+        //        XLOG(ing->source_endpoint_is_sap);
+        //        psi.incoming_ttl = 0;
+
+        if (sub_nexthop_record->global_sub_index)
+        {
+            *hash_res = vfp_ing_hash64(sub_nexthop_record->global_sub_index);
+            pchip_logpf("hash_res %#x sub-host %#x\n", *hash_res, sub_nexthop_record->global_sub_index);
+            LOG();
+        }
+
+        if (sub_nexthop_record->is_lac)
+        {
+            // l2tp tunnels should also hit a sub record where this is set
+            pchip_logpf("sub nexthop to lac l2tp_hdr_length %u is_l2tp_to_ipoe %u from_sap %u\n", l2tp_hdrs_length,
+                    sub_nexthop_record->is_l2tp_to_ipoe, ing->source_endpoint_is_sap);
+            msm->l2_hdr_size = ing->ip_routing.l2tp_hdrs_length;
+
+            if (sub_nexthop_record->is_l2tp_mg)
+            {
+                pchip_logpf("Sub is l2tp mobile Chunk id %u\n", sub_nexthop_record->msm_chunk_id);
+                goto sub_nh_l2tp_mobile;
+            }
+        }
+        return true;
+
+sub_nh_l2tp_mobile:
+        pchip_log_criteria("l2tp-mg=1");
+
+        //check for PPP data vs control. If PPP ctrl send to CPM.
+        POS_ADDR_AND_CTRL ppp_addr_ctrl_bytes;
+        convert_to_POS_ADDR_AND_CTRL(&ppp_addr_ctrl_bytes, mpls_or_ipv4 + ing->ip_routing.l2tp_hdrs_length - sizeof(POS_ADDR_AND_CTRL), 0);
+
+        pchip_logpf("L2TP PPP Addr 0x%x Ctrl 0x%x\n", ppp_addr_ctrl_bytes.addr, ppp_addr_ctrl_bytes.ctrl);
+        if (ppp_addr_ctrl_bytes.addr != POS_ADDR_VAL) goto discard_frame_invalid_l2tp_header;
+        if (ppp_addr_ctrl_bytes.ctrl != POS_CTRL_VAL) goto discard_frame_invalid_l2tp_header;
+
+        POS_HEADER ppp_protocol;
+        convert_to_POS_HEADER(&ppp_protocol, mpls_or_ipv4 + ing->ip_routing.l2tp_hdrs_length, 0);
+
+        pchip_logpf("L2TP PPP Protocol 0x%x\n", ppp_protocol.protocol_id);
+        if ((ppp_protocol.protocol_id & PPP_PROTOCOL_IS_CONTROL) == 0)
+        {
+            /*LOG(); TB TODO*/
+            // overide ip offset with l2tp_hdr_len
+            msm->msm_sess_ip_offset = (ing->ip_routing.l2tp_hdrs_length - (sizeof(IPV4_HEADER)+sizeof(UDP_HEADER))) + POS_HEADER__BYTES; // + POS_ADDR_AND_CTRL__BYTES are already in l2tp_hdrs_length
+            pchip_logpf("L2TP and PPP hdr len %d\n", msm->msm_sess_ip_offset);
+            goto l2tp_ppp_data_to_msm;
+        }
+        if (ppp_protocol.protocol_id != PPP_PROTOCOL_LCP)
+        {
+            /*LOG(); TB TODO*/
+            goto l2tp_ppp_control_frame;
+        }
+
+        INGRESS_PPP_LCP_HDR ppp_lcp_hdr;
+        convert_to_INGRESS_PPP_LCP_HDR(&ppp_lcp_hdr, mpls_or_ipv4 + ing->ip_routing.l2tp_hdrs_length, 0);
+        pchip_logpf("l2tp_ppp_control, prot_id = 0x%x lcp_code = 0x%x\n", ppp_lcp_hdr.ppp_prot_id, ppp_lcp_hdr.ppp_lcp_code);
+
+
+        if ((ppp_lcp_hdr.ppp_lcp_code == PPP_LCP_CODE_ECHO_REQ) ||
+                (ppp_lcp_hdr.ppp_lcp_code == PPP_LCP_CODE_ECHO_REPLY))
+        {
+            /*LOG(); TB TODO*/
+            goto l2tp_ppp_lcp_echo_req_reply;
+        }
+
+l2tp_ppp_control_frame:
+        /*LOG(); TB TODO*/
+        SET_TO_CPM_CODE(&ing->cpm_reason, TO_CPM_RAW_REASON_PPPOE_CONTROL);
+        pchip_logpf("L2TP PPP Redirect PPP Control to CPM\n");
+        goto send_routed_frame_to_cpm;
+
+l2tp_ppp_lcp_echo_req_reply:
+        // Use reason code TO_CPM_RAW_REASON_PPPOE_CONTROL instead of
+        // TO_CPM_RAW_REASON_PPPOE_LCP_ECHO, so that the packet goes to
+        // CPU1, where the L2TP Proxy Agent is running.
+        /*LOG(); TB TODO*/
+        SET_TO_CPM_CODE(&ing->cpm_reason, TO_CPM_RAW_REASON_PPPOE_CONTROL);
+        pchip_logpf("L2TP PPP Redirect LCP Echo to CPM\n");
+        goto send_routed_frame_to_cpm;
+
+l2tp_ppp_data_to_msm:
+        /*LOG(); TB TODO*/
+        pchip_logpf("L2TP PPP Data frame Chunk id %u\n", sub_nexthop_record->msm_chunk_id);
+        msm->chunk_id = sub_nexthop_record->msm_chunk_id;
+        msm->msm_reason_code = TO_MSM_REASON_L2TP_OR_EXT;
+        msm->msm_internal_nexthop_index = 0;
+        if (likely(vfp_ing_iom_forward_to_msm(pDesc, worker_info, port_record, ing, source_vrf_id, msm, pad_to_remove, ing_qos, hash_res))) {
+        //    return true;
+        }
+       // else
+            return false;
+
+       // return true;
+
+sub_nh_not_found:
+sub_nh_unreachable:
+        pchip_logpf("Can't find subscriber nexthop\n");
+        goto host_unreachable_routing;
+    }
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+    /**************************************************************************************************
     * to cpm code
     ***************************************************************************************************/
 
@@ -4549,6 +4848,10 @@ fab_hdr_core_ipv4_vprn:
             LOG();
             sw_hdr->parm.core.cp3.ucast.nw.is_vprn = 1;                   // 6PE/6VPE
         }
+        if (msm->svc_bits.is_sap_to_l2tp)
+        {
+            sw_hdr->parm.core.cp3.ucast.nw.is_vprn = 1;
+        }
         // no 6to4 tunnel support yet
     }
 
@@ -6684,6 +6987,12 @@ pchip_run_filters_v6:
     goto multicast_and_routing_common_v6;
 
 pchip_run_filters:
+    if (msm.msm_l2tp_ip_not_ppp && (ing.is_ipv6 == 0))
+    {
+        msm.svc_bits.is_sap_to_l2tp = 1;
+        pchip_logpf("pchip_run_filters: msm.msm_l2tp_ip_not_ppp\n");
+    }
+
     if (unlikely(ing.is_nat_sub))
     {
       return vfp_ing_l2tp_tunnel_from_sap(pDesc, worker_info, &ing, &ing_qos, qos_queue_info, port_record, sap_info, subscriber_record, sub_app_rec, &msm);
@@ -7037,13 +7346,85 @@ gre_common_network_code:
     goto mpls_common_network_code;
 
 
-
+#define IHL_FROM_IP_HDR(ip) (((ip).version_ihl) & 0xF)
 
     /**************************************************************************************************
     * common ip hdr verification code
     ***************************************************************************************************/
 
 verify_ip_hdr:
+
+    pchip_logpf("Arun Frame to CPM reason: %d\n", ing.cpm_reason.code);
+
+    if (ing.cpm_reason.code == TO_CPM_RAW_REASON_L2TP_CONTROL)
+    {
+
+        XLOG(ing.is_mpls);
+        UINT8 *l2tp_ptr = ing.ip_ptr + sizeof(IPV4_HEADER)+sizeof(UDP_HEADER);
+//        if (IHL_FROM_IP_HDR(ipv4_hdr) != (IPV4_HEADER__BYTES/4)) goto done_l2tp_check;
+
+        L2TP_HEADER l2tp_hdr;
+        convert_to_L2TP_HEADER(&l2tp_hdr, l2tp_ptr);
+        pchip_logpf("control: %d, vers: 0x%x\n", l2tp_hdr.flags_and_vers.control, l2tp_hdr.flags_and_vers.version);
+        if (l2tp_hdr.flags_and_vers.control)
+        {
+            LOG();
+            goto done_l2tp_check;
+        }
+        if (l2tp_hdr.flags_and_vers.version != L2TP_VERSION)
+        {
+            LOG();
+            goto done_l2tp_check;
+        }
+
+        // Length validation - the normal routing code ensures the frame is large enough given the length in the ip hdr.
+        // This code ensures the IP+UDP+L2TP+PosAC hdrs < length in ip hdr, and IP+UDP+L2TP+PosAC hdrs < 128 (the max we strip).
+        // Note, no validation done of L2TP length, it is ignored (though L2TP hdr will still be parsed correctly if present)
+
+        if (l2tp_hdr.flags_and_vers.length_present)
+        {
+            LOG();
+            l2tp_ptr += 2; // +2=size of length field
+        }
+        if (l2tp_hdr.flags_and_vers.sequence_present)
+        {
+            // Skip over the sequence numbers, we don't look at them if they are present
+            LOG();
+            l2tp_ptr += 4; // +4=size of sequence field
+        }
+        if (l2tp_hdr.flags_and_vers.offset_present)
+        {
+            L2TP_HEADER_AND_OFFSET l2tp_hdr_and_off;
+            LOG();
+            convert_to_L2TP_HEADER_AND_OFFSET(&l2tp_hdr_and_off, l2tp_ptr);
+            pchip_logpf("Adding l2tp offset %u\n", l2tp_hdr_and_off.offset_length);
+            if (l2tp_hdr_and_off.offset_length >= 128) goto done_l2tp_check; // only support 7 bit offset length
+            l2tp_ptr += (UINT8) (l2tp_hdr_and_off.offset_length & 0x7f);
+            l2tp_ptr += sizeof(L2TP_HEADER) + sizeof(POS_ADDR_AND_CTRL) + 2; // +2 = offset_length size
+        }
+        else
+        {
+            l2tp_ptr += sizeof(L2TP_HEADER) + sizeof(POS_ADDR_AND_CTRL);
+        }
+
+        UINT16 l2tp_hdrs_length = (l2tp_ptr - ing.ip_ptr);
+#if 0
+        if (ipv4_hdr.total_length <= l2tp_hdrs_length)
+        {
+            LOG();
+            pchip_logpf("L2TP: invalid ip hdr len %u l2tp hdrs %u\n", ipv4_hdr.total_length, l2tp_hdrs_length);
+            goto done_l2tp_check;
+        }
+#endif
+        if (l2tp_hdrs_length >= 128) goto done_l2tp_check; // only support 7 bits of hdr to strip
+
+        pchip_logpf("L2TP got valid hdrs length %u\n", l2tp_hdrs_length);
+        // In the l2tp code on the second P the frame is discarded unless l2tp_hdr_length is non-zero.
+        ing.ip_routing.l2tp_hdrs_length = l2tp_hdrs_length;
+    }
+
+done_l2tp_check:
+
     if_record = &VFP_INGRESS_IP_INTERFACE_RECORD_TABLE_CTABLE[source_interface];
     vrf_record = INGRESS_VRF_TABLE_CTABLE[source_vrf_id];
     pchip_logpf("IPv4 TTL %s mode from %s record\n", ttl_mode_to_str(vrf_record.ttl_flags.ttl_mode), source_vrf_id == 0 ? "GRT" : "VRF");
@@ -7662,6 +8043,96 @@ handle_dest_and_q_ucast:
         sw_hdr->common.has_ipv6_extra = 1;
     }
 
+#if 0
+    if (msm.svc_bits.is_sap_to_l2tp)
+    {
+        SW_FAB_HDR_L2TP_EXTRA l2tp_extra;
+//        UINT8 msm_encap_bytes_new[NP_INGRESS_MSM_P0_ENCAP_BYTES];
+//        PCHIP_ZERO(msm_encap_bytes_new);
+//        UINT8 *msm_encap_ptr = msm_encap_bytes_new;
+//        UINT8 *msm_encap_ptr = (UINT8 *)(sw_hdr + 1);
+        UINT8 *msm_encap_ptr = (UINT8 *) sw_hdr + extra_header_size + sizeof(*sw_hdr);
+
+        XLOG(sw_hdr->parm.core.cp1.flags.ip_not_mpls);
+        PCHIP_ZERO(l2tp_extra);
+        //l2tp_extra.binding_and_session.binding_index = psi.svc.non_vxlan.sap_sdp_dest.sdp_idx;
+        //l2tp_extra.binding_and_session.session_id = psi.l2tp_or_gtp_session.session_id;
+#if INGRESS_MSM_FWD_SUPPORT
+        if (msm.msm_l2tp_ip_not_ppp)
+        {
+            UINT8 bitsof_l2tp_tunnel_id_lsb = 8;
+            l2tp_extra.binding_and_session.binding_index = (ing.ip_routing.l2tp_tunnel_id_msb << bitsof_l2tp_tunnel_id_lsb) & (1 << bitsof_l2tp_tunnel_id_lsb);
+            l2tp_extra.binding_and_session.binding_index |= ((ing.ip_routing.l2tp_tunnel_id_lsb) & ((1 << bitsof_l2tp_tunnel_id_lsb) - 1));
+            //pchip_logpf("To %s tunnel - sess %#x bind %#x \n", msm.l2tp_or_gtp_session.is_gtp ? "GTP" : "MSM L2TP", msm.l2tp_or_gtp_session.session_id, psi.svc.non_vxlan.sap_sdp_dest.sdp_idx);
+            pchip_logpf("To %s tunnel - sess %#x bind %#x \n", msm.l2tp_or_gtp_session.is_gtp ? "GTP" : "MSM L2TP", msm.l2tp_or_gtp_session.session_id, l2tp_extra.binding_and_session.binding_index);
+        }
+        //l2tp_extra.binding_and_session.ip_not_ppp = (p1_flags.strip_l2_hdr.l2tp_ip_not_ppp | msm.msm_l2tp_ip_not_ppp);
+        l2tp_extra.binding_and_session.ip_not_ppp = msm.msm_l2tp_ip_not_ppp;
+#else
+        //l2tp_extra.binding_and_session.ip_not_ppp = p1_flags.strip_l2_hdr.l2tp_ip_not_ppp;
+        l2tp_extra.binding_and_session.ip_not_ppp = msm.msm_l2tp_ip_not_ppp;;
+#endif
+        //pchip_logpf("To %s tunnel - sess %#x bind %#x (stripping %u)\n", psi.l2tp_or_gtp_session.is_gtp ? "GTP" : "L2TP", psi.l2tp_or_gtp_session.session_id, psi.svc.non_vxlan.sap_sdp_dest.sdp_idx, p1_flags.strip_l2_hdr.l2_hdr_size);
+        pchip_logpf("To %s tunnel - sess %#x bind %#x (stripping %u)\n", msm.l2tp_or_gtp_session.is_gtp ? "GTP" : "L2TP", msm.l2tp_or_gtp_session.session_id, l2tp_extra.binding_and_session.binding_index, msm.l2_hdr_size);
+
+// TODO: OUT_FRAME2_EXTRA_HDR_PTR __DO_NOT_COMMIT__
+
+//        PCHIP_MEMSET(OUT_FRAME2_EXTRA_HDR_PTR + (sw_hdr.common.has_dpi_extra ? SW_FAB_HDR_DPI_EXTRA__BYTES : 0), 0, SW_FAB_HDR_L2TP_EXTRA__BYTES);
+
+        pchip_logpf("payload_length: %d, output_frame_offset: %d, msm.l2_hdr_size: %d, extra_header_size: %d\n",
+                payload_length, output_frame_offset, msm.l2_hdr_size, extra_header_size);
+        //output_frame_offset += p1_flags.strip_l2_hdr.l2_hdr_size;
+        output_frame_offset += msm.l2_hdr_size;
+        //payload_length -= p1_flags.strip_l2_hdr.l2_hdr_size;
+        payload_length -= msm.l2_hdr_size;
+
+#if 0
+        XLOG(psi.l2tp_or_gtp_session.is_gtp);
+        if (psi.l2tp_or_gtp_session.is_gtp)
+        {
+            l2tp_extra.binding_and_session.is_gtp = 1;
+            PCHIP_ASSERT(!sw_hdr.common.has_dpi_extra);
+            L2TP_EXTRA_WITH_GTP_ENCAP l2tp_gtp_extra;
+            l2tp_gtp_extra.l2tp_hdr_extra = l2tp_extra;
+
+            l2tp_gtp_extra.udp.ports.source = gtp_encap_info.udp_src_port;
+            l2tp_gtp_extra.udp.ports.dest = UDP_PORT_GTP_USER;
+            l2tp_gtp_extra.udp.length = payload_length + UDP_HEADER__BYTES + GTP_HEADER__BYTES - FCS_BYTES;
+            l2tp_gtp_extra.udp.checksum = 0;
+
+            l2tp_gtp_extra.gtp.hdr.ver_flags = GTP_HEADER_V1_VER_FLAG_BYTE;
+            l2tp_gtp_extra.gtp.hdr.type = GTP_HEADER_VX_TYPE_TPDU;
+            l2tp_gtp_extra.gtp.hdr.len = payload_length - FCS_BYTES;
+            l2tp_gtp_extra.gtp.te_id = gtp_encap_info.te_id;
+
+            convert_from_L2TP_EXTRA_WITH_GTP_ENCAP(&l2tp_gtp_extra, OUT_FRAME2_EXTRA_HDR_PTR);
+
+            out_frame2_extra_hdr_len += UDP_HEADER__BYTES + GTP_HEADER__BYTES;
+            XLOG(sw_hdr.parm.core.cp1.flags.is_ipv6);
+        }
+        else
+#endif
+        {
+            pchip_logpf("msm_encap_ptr-B4:  ");
+            for (int i = 0; i < SW_FAB_HDR_L2TP_EXTRA__BYTES; i++)
+                pchip_logpf("%d ", msm_encap_ptr[i]);
+            pchip_logpf("\n");
+            convert_from_SW_FAB_HDR_L2TP_EXTRA(&l2tp_extra, msm_encap_ptr);
+//            PCHIP_MEMCPY(&(msm_encap_ptr[sizeof(SW_FAB_HDR_L2TP_EXTRA__BYTES)]), ing.ip_ptr, NP_INGRESS_MSM_P0_ENCAP_BYTES-SW_FAB_HDR_L2TP_EXTRA__BYTES);
+//            PCHIP_MEMCPY(ing.ip_ptr, msm_encap_ptr, NP_INGRESS_MSM_P0_ENCAP_BYTES);
+            pchip_logpf("msm_encap_ptr-A4:  ");
+            for (int i = 0; i < SW_FAB_HDR_L2TP_EXTRA__BYTES; i++)
+                pchip_logpf("%d ", msm_encap_ptr[i]);
+            pchip_logpf("\n");
+            sw_hdr->parm.core.cp1.flags.is_ipv6 = 0;
+        }
+
+        sw_hdr->common.has_l2tp_extra = 1;
+        //out_frame2_extra_hdr_len += SW_FAB_HDR_L2TP_EXTRA__BYTES;
+        extra_header_size += SW_FAB_HDR_L2TP_EXTRA__BYTES;
+    }
+#endif
+
     vfp_ing_build_core_swfab_hdr_common(sw_hdr, &ing, if_dest_info ? if_dest_info->to_svc_interface : 0, 
                             &nexthop_ip_and_l2tp, dest_vrf_id,
                             hash_res, &p1_flags, new_nhlfe_inner,
@@ -7686,6 +8157,63 @@ handle_dest_and_q_ucast:
         vfp_ing_check_dup_to_mscp_li(pDesc, port_record, extra_header_size, payload_length, output_frame_offset, &msm, &msm_int_info, &msm_tunnel_id, &ing);
     }
 
+
+#if 0
+    {
+        UINT8 *msm_encap_ptr = (UINT8 *) sw_hdr + extra_header_size + sizeof(*sw_hdr);
+        pchip_logpf("msm_encap_ptr-AA4:  ");
+        for (int i = 0; i < SW_FAB_HDR_L2TP_EXTRA__BYTES; i++)
+            pchip_logpf("%d ", msm_encap_ptr[i]);
+        pchip_logpf("\n");
+
+    }
+#endif
+    if (msm.svc_bits.is_sap_to_l2tp)
+    {
+        SW_FAB_HDR_L2TP_EXTRA l2tp_extra;
+        UINT8 *msm_encap_ptr = (UINT8 *) sw_hdr + extra_header_size + sizeof(*sw_hdr);
+
+        XLOG(sw_hdr->parm.core.cp1.flags.ip_not_mpls);
+        PCHIP_ZERO(l2tp_extra);
+        l2tp_extra.binding_and_session.session_id = msm.l2tp_or_gtp_session.session_id;
+#if INGRESS_MSM_FWD_SUPPORT
+        if (msm.msm_l2tp_ip_not_ppp)
+        {
+            UINT8 bitsof_l2tp_tunnel_id_lsb = 8;
+            l2tp_extra.binding_and_session.binding_index = (ing.ip_routing.l2tp_tunnel_id_msb << bitsof_l2tp_tunnel_id_lsb) & (1 << bitsof_l2tp_tunnel_id_lsb);
+            l2tp_extra.binding_and_session.binding_index |= ((ing.ip_routing.l2tp_tunnel_id_lsb) & ((1 << bitsof_l2tp_tunnel_id_lsb) - 1));
+            pchip_logpf("To %s tunnel - sess %#x/%#x bind %#x \n", msm.l2tp_or_gtp_session.is_gtp ? "GTP" : "MSM L2TP", msm.l2tp_or_gtp_session.session_id, l2tp_extra.binding_and_session.session_id, l2tp_extra.binding_and_session.binding_index);
+        }
+        l2tp_extra.binding_and_session.ip_not_ppp = msm.msm_l2tp_ip_not_ppp;
+#else
+        l2tp_extra.binding_and_session.ip_not_ppp = msm.msm_l2tp_ip_not_ppp;;
+#endif
+        pchip_logpf("To %s tunnel - sess %#x/%#x bind %#x (stripping %u)\n", msm.l2tp_or_gtp_session.is_gtp ? "GTP" : "L2TP", msm.l2tp_or_gtp_session.session_id, l2tp_extra.binding_and_session.session_id, l2tp_extra.binding_and_session.binding_index, msm.l2_hdr_size);
+
+        // TODO: OUT_FRAME2_EXTRA_HDR_PTR __DO_NOT_COMMIT__
+
+        pchip_logpf("payload_length: %d, output_frame_offset: %d, msm.l2_hdr_size: %d, extra_header_size: %d\n",
+                payload_length, output_frame_offset, msm.l2_hdr_size, extra_header_size);
+
+        output_frame_offset += msm.l2_hdr_size;
+        payload_length -= msm.l2_hdr_size;
+
+        PCHIP_MEMSET(msm_encap_ptr, 0, SW_FAB_HDR_L2TP_EXTRA__BYTES);
+        pchip_logpf("msm_encap_ptr-B4:  ");
+        for (int i = 0; i < SW_FAB_HDR_L2TP_EXTRA__BYTES; i++)
+            pchip_logpf("%d ", msm_encap_ptr[i]);
+        pchip_logpf("\n");
+        convert_from_SW_FAB_HDR_L2TP_EXTRA(&l2tp_extra, msm_encap_ptr);
+        pchip_logpf("msm_encap_ptr-A4:  ");
+        for (int i = 0; i < SW_FAB_HDR_L2TP_EXTRA__BYTES; i++)
+            pchip_logpf("%d ", msm_encap_ptr[i]);
+        pchip_logpf("\n");
+        sw_hdr->parm.core.cp1.flags.is_ipv6 = 0;
+
+        sw_hdr->common.has_l2tp_extra = 1;
+        extra_header_size += SW_FAB_HDR_L2TP_EXTRA__BYTES;
+    }
+
     return vfp_ing_build_qhdr_and_output(pDesc, worker_info, sw_hdr, dest_queue, queue_stat_addr,
                                          (ing_qos.drop_pref == DROP_PREF_HIGH_PRIORITY),
                                          output_frame_offset, extra_header_size, payload_length, 0 /*mgid*/, &msm);
@@ -8160,6 +8688,23 @@ got_sdf:
 
     if (unlikely(msm_bearer_rec.nh_info.nh_index == 0)) { LOG_MSM(); goto discard_msm_no_nexthop; }
 
+    if (msm_bearer_rec.nh_info.encap == MSM_ENCAP_L2TP)
+    {
+        UINT8 bitsof_l2tp_tunnel_id_lsb = 8;
+
+        msm.l2tp_or_gtp_session.session_id = (msm_bearer_rec.tunnel_id & ((1 << L2TP_TUNNEL_ID__BITS) - 1));
+        ing.ip_routing.l2tp_tunnel_id_msb = ((msm_bearer_rec.tunnel_id >> (L2TP_TUNNEL_ID__BITS+bitsof_l2tp_tunnel_id_lsb)) & ((1 << (L2TP_TUNNEL_ID__BITS-bitsof_l2tp_tunnel_id_lsb)) - 1));
+        ing.ip_routing.l2tp_tunnel_id_lsb = ((msm_bearer_rec.tunnel_id >> L2TP_TUNNEL_ID__BITS) & ((1 << L2TP_TUNNEL_ID__BITS) - 1));
+        msm.msm_l2tp_ip_not_ppp = 1;
+
+        pchip_log_criteria("l2tp-mg-ingress-ul");
+
+        pchip_logpf("GTP To L2TP tunnel - sess %#x bind %#x (stripping %u)\n", (msm_bearer_rec.tunnel_id & ((1 << L2TP_TUNNEL_ID__BITS) - 1)),
+                ((msm_bearer_rec.tunnel_id >> L2TP_TUNNEL_ID__BITS) & ((1 << L2TP_TUNNEL_ID__BITS) - 1)));
+
+        goto msm_l2tp_encap_join;
+    }
+
 
     if ((msm_bearer_rec.nh_info.encap == MSM_ENCAP_GTP) ||
         (msm_bearer_rec.nh_info.encap == MSM_ENCAP_GTP_LPBK) ||
@@ -8244,6 +8789,7 @@ got_sdf:
 #endif
     }
 
+msm_l2tp_encap_join:
 
     ing.ip_ptr = frame_start + msm.msm_overhead_length;
     pchip_logpf("Direction %s Encap %d Headers %d Gateway Instance %d Nexthop Id %d\n",
@@ -9239,7 +9785,12 @@ mscp_route_packet:
     hash_res = vfp_ing_hash_mix(tunnel_bytes, 32, hash_res);
     pchip_logpf("MSCP Hash 0x%06x\n", hash_res);
 
-    
+    if (msm.msm_l2tp_ip_not_ppp && (ing.is_ipv6 == 0))
+    {
+        msm.svc_bits.is_sap_to_l2tp = 1;
+        pchip_logpf("msm.msm_l2tp_ip_not_ppp\n");
+    }
+
     goto multicast_and_routing_common;
     }
     else
diff --git a/pchip_code/vfp_tables.cpp b/pchip_code/vfp_tables.cpp
index 5bf3044..166cfe9 100755
--- a/pchip_code/vfp_tables.cpp
+++ b/pchip_code/vfp_tables.cpp
@@ -1083,18 +1083,19 @@ void write_INGRESS_SUBSCRIBER_RECORD2_TABLE_VFP(INGRESS_SUBSCRIBER_RECORD2 *p_in
     p_out->ipv6_sub_prefix_len = p_in->ipv6_sub_prefix_len;
     p_out->subscriber_disabled = p_in->subscriber_disabled;
     p_out->is_incipient_host = p_in->is_incipient_host;
-#ifdef PENDING_SR_MERGE
-    p_out->is_l2tp = p_in->normal_host.host_info.is_l2tp;
-    if (p_in->normal_host.host_info.is_l2tp)
+//#ifdef PENDING_SR_MERGE
+    p_out->is_l2tp = p_in->normal_host.l2tp_info.is_l2tp;
+    //if (p_in->normal_host.host_info.is_l2tp)
+    if (p_in->normal_host.l2tp_info.is_l2tp)
     {
-        p_out->normal_host.host_info.l2tp_info = p_in->normal_host.host_info.l2tp_info;
+        p_out->normal_host.host_info.l2tp_info = p_in->normal_host.l2tp_info;
     }
     else
     {
-        p_out->normal_host.host_info.source_vrf.replace_vrf_id_bit = p_in->normal_host.host_info.use_source_vrf;
-        p_out->normal_host.host_info.source_vrf.vrf_id = p_in->normal_host.host_info.use_source_vrf ? p_in->normal_host.host_info.source_vrf : 0;
+//        p_out->normal_host.host_info.source_vrf.replace_vrf_id_bit = p_in->normal_host.host_info.use_source_vrf;
+//        p_out->normal_host.host_info.source_vrf.vrf_id = p_in->normal_host.host_info.use_source_vrf ? p_in->normal_host.host_info.source_vrf : 0;
     }
-#endif
+//#endif
     VFP_TBL_UNLOCK();
 }
 
@@ -1243,11 +1244,16 @@ BOOLEAN read_EGRESS_SUB_RECORD_TABLE_VFP(EGRESS_SUB_RECORD *p_out, UINT32 n)
     
     p_out->key.s.global_sap_index = p_in->one.key.global_sap_index; 
     p_out->key.s.is_ipv6          = p_in->one.key.is_ipv6;
+    p_out->key.s.is_l2tp          = p_in->one.key.is_l2tp;
 
     if (p_out->key.s.is_ipv6)
     {
         rte_memcpy(&p_out->key.s.dest_ipv6, &p_in->one.key.dest_ipv6, sizeof(p_out->key.s.dest_ipv6)); 
     }
+    else if (p_out->key.s.is_l2tp)
+    {
+        rte_memcpy(&p_out->key.s.l2tp, &p_in->one.key.l2tp, sizeof(p_out->key.s.l2tp));
+    }
     else
     {
         rte_memcpy(&p_out->key.s.dest_ip, &p_in->one.key.dest_ip, sizeof(p_out->key.s.dest_ip)); 
@@ -1269,11 +1275,16 @@ void write_EGRESS_SUB_RECORD_TABLE_VFP(EGRESS_SUB_RECORD *p_in, UINT32 n)
 
     p_out->one.key.global_sap_index = p_in->key.s.global_sap_index; 
     p_out->one.key.is_ipv6          = p_in->key.s.is_ipv6;
+    p_out->one.key.is_l2tp          = p_in->key.s.is_l2tp;
     
     if (p_out->one.key.is_ipv6)
     {
         rte_memcpy(&p_out->one.key.dest_ipv6, &p_in->key.s.dest_ipv6, sizeof(p_out->one.key.dest_ipv6)); 
     }
+    else if (p_out->one.key.is_l2tp)
+    {
+        rte_memcpy(&p_out->one.key.l2tp, &p_in->key.s.l2tp, sizeof(p_out->one.key.l2tp));
+    }
     else
     {
         rte_memcpy(&p_out->one.key.dest_ip, &p_in->key.s.dest_ip, sizeof(p_out->one.key.dest_ip)); 
@@ -1298,6 +1309,7 @@ BOOLEAN read_EGRESS_SUB_RECORD_TABLE_2_VFP(EGRESS_SUB_RECORD_2 *p_out, UINT32 n)
     p_out->v6_filter            = p_in->two.v6_filter;
     p_out->lag_dest_port        = p_in->two.lag_dest_port;
     p_out->qos_filter_index     = p_in->two.qos_filter_index;
+    p_out->pppoe_config         = p_in->two.pppoe_config;
     p_out->mtu_bytes            = p_in->two.mtu_bytes;
     p_out->remarking_by_sub_fli = p_in->two.remarking_by_sub_fli;
     p_out->clear_df_for_frag    = p_in->two.clear_df_for_frag;
@@ -1315,6 +1327,7 @@ void write_EGRESS_SUB_RECORD_TABLE_2_VFP(EGRESS_SUB_RECORD_2 *p_in, UINT32 n)
     p_out->two.v6_filter            = p_in->v6_filter;
     p_out->two.lag_dest_port        = p_in->lag_dest_port;
     p_out->two.qos_filter_index     = p_in->qos_filter_index;
+    p_out->two.pppoe_config         = p_in->pppoe_config;
     p_out->two.mtu_bytes            = p_in->mtu_bytes;
     p_out->two.remarking_by_sub_fli = p_in->remarking_by_sub_fli;
     p_out->two.clear_df_for_frag    = p_in->clear_df_for_frag;
@@ -1582,11 +1595,15 @@ VFP_DEFINE_TABLE_AND_READ_WRITE_FN(EGRESS_SDP_QTYPE_TABLE, ETHERTYPE)
 
 VFP_DEFINE_TABLE_AND_READ_WRITE_FN(EGRESS_MPLS_NHLFE_TABLE, EGRESS_MPLS_NHLFE_INFO)
 
+VFP_DEFINE_TABLE_AND_READ_WRITE_FN(EGRESS_L2TP_CFG_TABLE, EGRESS_L2TP_CONFIG)
+
 VFP_DEFINE_TABLE_AND_READ_WRITE_FN(EGRESS_NP_TLS_MCAST_TABLE, EGRESS_TLS_MCAST_LIST_INFO)
 VFP_DEFINE_TABLE_AND_READ_WRITE_FN(EGRESS_TLS_MCAST_LIST_TABLE, EGRESS_TLS_MCAST_ENTRY)
 VFP_DEFINE_TABLE_AND_READ_WRITE_FN(EGRESS_MCAST_LAG_INDEX_RECORD_TABLE, EGRESS_LAG_INDEX_RECORD)
 
 VFP_DEFINE_TABLE_AND_READ_WRITE_FN(EGRESS_SUB_INITIAL_VFP_HASH_TABLE, UINT32)
+VFP_DEFINE_TABLE_AND_READ_WRITE_FN(EGRESS_SUB_SRC_MAC_TABLE,  MAC_ADDRESS)
+VFP_DEFINE_TABLE_AND_READ_WRITE_FN(EGRESS_SUB_DEST_MAC_TABLE, MAC_ADDRESS)
 
 VFP_DEFINE_TABLE_AND_READ_WRITE_FN(EGRESS_DPISUB_SAP_RECORD_TABLE, EGRESS_DPISUB_RECORD)
 VFP_DEFINE_TABLE_AND_READ_WRITE_FN(EGRESS_DPISUB_SDP_RECORD_TABLE, EGRESS_DPISUB_RECORD)
@@ -1856,6 +1873,8 @@ vfp_init_tables_and_install_hooks(PP_PROG_MASK pp_mask, t_vfp_table_calloc_fn ta
     
     VFP_TABLE_ALLOCATE(EGRESS_MPLS_NHLFE_TABLE, EGRESS_MPLS_NHLFE_INFO, pp_mask);
 
+    VFP_TABLE_ALLOCATE(EGRESS_L2TP_CFG_TABLE, EGRESS_L2TP_CONFIG, pp_mask);
+
     VFP_TABLE_ALLOCATE(EGRESS_NP_TLS_MCAST_TABLE, EGRESS_TLS_MCAST_LIST_INFO, pp_mask); 
     VFP_TABLE_ALLOCATE(EGRESS_TLS_MCAST_LIST_TABLE, EGRESS_TLS_MCAST_ENTRY, pp_mask); 
     VFP_TABLE_ALLOCATE(EGRESS_MCAST_LAG_INDEX_RECORD_TABLE, EGRESS_LAG_INDEX_RECORD, pp_mask); 
@@ -1863,6 +1882,8 @@ vfp_init_tables_and_install_hooks(PP_PROG_MASK pp_mask, t_vfp_table_calloc_fn ta
     VFP_TABLE_ALLOCATE(EGRESS_SUB_INITIAL_VFP_HASH_TABLE, UINT32, pp_mask);
     VFP_TABLE_ALLOCATE_FULL(EGRESS_SUB_RECORD_TABLE, VFP_EGRESS_SUB_RECORD_TABLE, VFP_EGRESS_SUB_RECORD, pp_mask);
     VFP_TABLE_REGISTER_HOOKS(EGRESS_SUB_RECORD_TABLE_2); // combined with above, so just need the hooks.
+    VFP_TABLE_ALLOCATE(EGRESS_SUB_SRC_MAC_TABLE,  MAC_ADDRESS, pp_mask);
+    VFP_TABLE_ALLOCATE(EGRESS_SUB_DEST_MAC_TABLE, MAC_ADDRESS, pp_mask);
     
     VFP_TABLE_ALLOCATE(EGRESS_DPISUB_SAP_RECORD_TABLE, EGRESS_DPISUB_RECORD, pp_mask);
     VFP_TABLE_ALLOCATE(EGRESS_DPISUB_SDP_RECORD_TABLE, EGRESS_DPISUB_RECORD, pp_mask);
diff --git a/pchip_code/vfp_tables.h b/pchip_code/vfp_tables.h
index 2883f1c..19ce947 100644
--- a/pchip_code/vfp_tables.h
+++ b/pchip_code/vfp_tables.h
@@ -373,12 +373,14 @@ typedef struct
     
     union
     {
-        IP_ADDRESS                  dest_ip;         // !is_ipv6
-        EGRESS_SUB_IPV6_PREFIX      dest_ipv6;       // !is_ipv6;
+        IP_ADDRESS                  dest_ip;         // !is_ipv6 && !is_l2tp
+        EGRESS_SUB_IPV6_PREFIX      dest_ipv6;       // is_ipv6 && !is_l2tp;
+        L2TP_TUNNEL_AND_SESSION     l2tp;            //  is_l2tp
 
     };                                               // +8 = 12
     
     BOOLEAN                         is_ipv6;         // +1 = 13
+    BOOLEAN                         is_l2tp;         // +1 = 13
                                                      // +3 (pad) = 16 
 } VFP_EGRESS_SUBSCRIBER_KEY;
 
@@ -399,10 +401,11 @@ typedef struct
     EGRESS_FILTER_CONFIG        v6_filter;           // +2 = 6         
     PCHIP_ETH_PORT_NUM          lag_dest_port;       // +2 = 8       
     FILTER_LIST_INDEX           qos_filter_index;    // +2 = 10       
-    IOM_FRAME_LEN               mtu_bytes;           // +2 = 12      
-    BOOLEAN                     remarking_by_sub_fli;// +1 = 13
-    BOOLEAN                     clear_df_for_frag;   // +1 = 14
-                                                     // +2 (pad) = 16 
+    EGRESS_PPPOE_CONFIG         pppoe_config;        // +2 = 12
+    IOM_FRAME_LEN               mtu_bytes;           // +2 = 14
+    BOOLEAN                     remarking_by_sub_fli;// +1 = 15
+    BOOLEAN                     clear_df_for_frag;   // +1 = 16
+
 } VFP_EGRESS_SUB_RECORD_2;
 
 typedef struct {
@@ -715,6 +718,9 @@ extern ETHERTYPE *EGRESS_SDP_QTYPE_TABLE_CTABLE;
 // mpls
 extern EGRESS_MPLS_NHLFE_INFO *EGRESS_MPLS_NHLFE_TABLE_CTABLE;
 
+// l2tpv2
+extern EGRESS_L2TP_CONFIG  *EGRESS_L2TP_CFG_TABLE_CTABLE;
+
 // vpls/tls
 extern EGRESS_TLS_MCAST_LIST_INFO *EGRESS_NP_TLS_MCAST_TABLE_CTABLE;     
 extern EGRESS_TLS_MCAST_ENTRY *EGRESS_TLS_MCAST_LIST_TABLE_CTABLE;
@@ -724,6 +730,8 @@ extern EGRESS_LAG_INDEX_RECORD *EGRESS_MCAST_LAG_INDEX_RECORD_TABLE_CTABLE;
 extern UINT32 *EGRESS_SUB_INITIAL_VFP_HASH_TABLE_CTABLE;
    
 extern VFP_EGRESS_SUB_RECORD *VFP_EGRESS_SUB_RECORD_TABLE_CTABLE;
+extern MAC_ADDRESS *EGRESS_SUB_SRC_MAC_TABLE_CTABLE;
+extern MAC_ADDRESS *EGRESS_SUB_DEST_MAC_TABLE_CTABLE;
 
 extern EGRESS_DPISUB_RECORD *EGRESS_DPISUB_SAP_RECORD_TABLE_CTABLE;
 extern EGRESS_DPISUB_RECORD *EGRESS_DPISUB_SDP_RECORD_TABLE_CTABLE;
